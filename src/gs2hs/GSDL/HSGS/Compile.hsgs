module GSDL.HSGS.Compile (gshsgs_compile_value, gshsgs_compile_expr, gshsgs_compile_arg, hspos, hspos_import) where

$gsimports

gshsgs_compile_value = [gs:value| λ 'pos0. λ 'env. λ 'pos1. λ 'e. analyze e.
    case expr.var 'v. (analyze hsgs.compiler.env.var.get v env.
        case just 'p. right p
    )
    case _. either.for 'p ← hsgs.compile-expr env hsgs.compiler.supply.env.empty pos1 e;. right 〈
        '0 ∝ ordered-set.∪ hsimport.<=>
            (ordered-set.from-list hsimport.<=> (hsimport.var qq{System.IO.Unsafe} qq{unsafePerformIO} : hsimport.var qq{GSI.Value} qq{gsthunk_w} : hspos-import : nil))
            (p #0)
        ;
        '1 ∝ hsexpr.applyvar qq{unsafePerformIO} (hsexpr.applyvar qq{gsthunk_w} (hspos pos0 : p #1 : nil) : nil);
    〉
|]

$gsdeclare hsgs.compile-app gshsgs_compile_app
$gsdeclare hsgs.compile-custom-app gshsgs_compile_custom_app
$gsdeclare hsgs.compile-generators gshsgs_compile_generators
$gsdeclare hsgs.compile-pat gshsgs_compile_pat
$gsdeclare hsgs.compile-fallible-pat gshsgs_compile_fallible_pat
$gsdeclare hsgs.compile-open-expr gshsgs_compile_open_expr

gshsgs_compile_expr = [gs:value| λ 'env. λ 'senv. λ 'pos. λ 'e. analyze e.
    case expr.natural 'n. right 〈
        '0 ∝ ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcnatural_w} : hspos-import : nil);
        '1 ∝ hsexpr.applyvar qq{gsbcnatural_w} (hspos pos : hsexpr.int n : nil);
    〉
    case expr.var 'v. (analyze hsgs.compiler.env.var.get v env.
        case nothing. left $ pos.fmt pos qq{§(gsvar.fmt-atom v) not in scope}
        case just 'p. right 〈
            '0 ∝ ordered-set.∪ hsimport.<=>
                (ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcenter_w} : hspos-import : nil))
                (p #0)
            ;
            '1 ∝ hsexpr.applyvar qq{gsbcenter_w} (hspos pos : p #1 : nil);
        〉
    )
    case expr.structure-literal 'gs 'pos1. hsgs.compile-generators env gs pos1
    case expr.app 'f 'x. (analyze x.
        case arg.here. hsgs.compile-app env pos f (x : nil)
        case arg.expr _ _. hsgs.compile-app env pos f (x : nil)
        case arg.app 'af 'ax. hsgs.compile-custom-app env pos f af (ax : nil)
    )
    case expr.generators 'gs 'pos1. hsgs.compile-generators env gs pos1
    case expr.pat 'p _. hsgs.compile-pat env pos p
    case expr.fallible-pat 'p _. hsgs.compile-fallible-pat env pos p
    case expr.open-expr 'e (just 'fvs). hsgs.compile-open-expr env pos fvs e
    case expr.missing-case. hsgs.compiler.env.gen-sym env $ λ 'xhs. λ 'env1. right 〈
        '0 ∝ ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcarg_w} : hspos-import : hsimport.var qq{GSI.ByteCode} qq{gsbcprim_w} : hspos-import : hsimport.var qq{GSI.CalculusPrims} qq{gspriminsufficientcases} : nil);
        '1 ∝ hsexpr.applyvar qq{gsbcarg_w} (hspos pos : hsexpr.lambda xhs (hsexpr.applyvar qq{gsbcprim_w} (hspos pos : hsexpr.var qq{gspriminsufficientcases} : hsexpr.var xhs : nil)) : nil);
    〉
|]

$gsdeclare need-here gsneed_here
$gsdeclare supply-here gssupply_here
$gsdeclare hsgs.compile-args gshsgs_compile_args

gshsgs_compile_app = [gs:value| λ 'env. λ 'pos. λ 'f. λ 'as. analyze f.
    case expr.var 'v. (analyze hsgs.compiler.env.var.get v env.
        case nothing. left $ pos.fmt pos qq{§(gsvar.fmt-atom v) not in scope}
        case just 'p. (analyze need-here as.
            case false. hsgs.compile-args pos p as nothing env
            case true. supply-here env pos (hsgs.compile-args pos p as)
        )
    )
    case expr.unary 'v. (analyze hsgs.compiler.env.var.get v (hsgs.compiler.env.unary.get env).
        case nothing. left $ pos.fmt pos qq{unary §(gsvar.fmt-atom v) not in scope}
        case just 'p. (analyze need-here as.
            case false. hsgs.compile-args pos p as nothing env
            case true. supply-here env pos (hsgs.compile-args pos p as)
        )
    )
    case expr.app 'f1 'a. hsgs.compile-app env pos f1 (a:as)
|]

-- To implement §gs{here}, we need to find the call stack for the whole application.
-- Check if that's needed and, if so, wrap the application in §hs{gsbcwithhere_w} and pass the call stack into §gs{hsgs.compile-arg}

gsneed_here = [gs:value| λ 'as. list.∃ (λ 'a. analyze a. case arg.here. true case _. false) as |]

gssupply_here = [gs:value|  λ 'env. λ 'pos. λ 'k. hsgs.compiler.env.gen-sym env $ λ 'herehs. λ 'env1. either.for 'p1 ← k (just herehs) env1;.
    right 〈
        '0 ∝ ordered-set.inserts hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcwithhere_w} : hspos-import : nil) (p1 #0);
        '1 ∝ hsexpr.applyvar qq{gsbcwithhere_w} (hspos pos : hsexpr.lambda herehs (p1 #1) : nil);
    〉
|]

gshsgs_compile_args = [gs:value| λ 'pos. λ 'p. λ 'as. λ 'mbhere. λ 'env1. either.for 'as1 ← either.mapM (hsgs.compile-arg mbhere env1) as;. right 〈
    '0 ∝ foldr (ordered-set.∪ hsimport.<=>) ordered-set.empty (
        ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcapply_w} : hspos-import : nil) :
        p #0 :
        map (λ 'p1. p1 #0) as1 <>
        nil
    );
    '1 ∝ hsexpr.applyvar qq{gsbcapply_w} (hspos pos : p #1 : hsexpr.list (map (λ 'p1. p1 #1) as1) : nil);
〉 |]

gshsgs_compile_custom_app = [gs:value| λ 'env. λ 'pos. λ 'f. λ 'af. λ 'as. analyze af.
    case arg.var 'v. (analyze hsgs.compiler.env.arg-var.get v env.
        case nothing. left $ pos.fmt pos qq{argument §(gsvar.fmt-atom v) not in scope}
        case just 'c. c env pos f as
    )
|]

gshsgs_compile_arg = [gs:value| λ 'mbhere. λ 'env. λ 'a. analyze a.
    case arg.expr 'pos (expr.var 'v). (analyze hsgs.compiler.env.var.get v env.
        case nothing. left $ pos.fmt pos qq{§(gsvar.fmt-atom v) not in scope}
        case just 'p. right 〈
            '0 ∝ ordered-set.∪ hsimport.<=> (ordered-set.singleton (hsimport.type qq{GSI.Value} qq{GSArg})) (p #0);
            '1 ∝ hsexpr.app (hsexpr.var qq{GSArgVar}) (p #1);
        〉
    )
    case arg.expr 'pos (expr.value-var 'v). (analyze hsgs.compiler.env.var.get v env.
        case nothing. left $ pos.fmt pos qq{§(gsvar.fmt-atom v) not in scope}
        case just 'p. right 〈
            '0 ∝ ordered-set.∪ hsimport.<=> (ordered-set.singleton (hsimport.type qq{GSI.Value} qq{GSArg})) (p #0);
            '1 ∝ hsexpr.app (hsexpr.var qq{GSArgVar}) (p #1);
        〉
    )
    case arg.expr 'pos 'e. either.for 'p ← hsgs.compile-expr env hsgs.compiler.supply.env.empty pos e;. right 〈
        '0 ∝ ordered-set.∪ hsimport.<=>
            (ordered-set.from-list hsimport.<=> (hsimport.type qq{GSI.Value} qq{GSArg} : hspos-import : nil))
            (p #0)
        ;
        '1 ∝ hsexpr.applyvar qq{GSArgExpr} (hspos pos : p #1 : nil);
    〉
    case arg.here. right 〈
        '0 ∝ ordered-set.from-list hsimport.<=> (hsimport.type qq{GSI.Value} qq{GSArg} : nil);
        '1 ∝ hsexpr.applyvar qq{GSArgVar} (hsexpr.var (analyze mbhere. case just 'here. here) : nil);
    〉
|]

$gsdeclare hsgs.compile-local-env gshsgs_compile_local_env

gshsgs_compile_open_expr = [gs:value| λ 'env. λ 'pos. λ 'fvs. λ 'e. hsgs.compiler.env.gen-sym env $ λ 'envhs. λ 'env1. either.for
        'p ← hsgs.compile-local-env env1 pos fvs envhs $ λ 'env2. hsgs.compile-expr env2 hsgs.compiler.supply.env.empty pos e;
    . right 〈
        '0 ∝ ordered-set.∪ hsimport.<=>
            (ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcarg_w} : hspos-import : nil))
            (p #0)
        ;
        '1 ∝ hsexpr.applyvar qq{gsbcarg_w} (hspos pos : hsexpr.lambda envhs (p #1) : nil);
    〉
|]

gshsgs_compile_local_env = [gs:value| λ 'env. λ 'pos. λ 'fvs. λ 'envhs. λ 'k. analyze fvs.
    case nil. k env
    case 'f0:'fvs1. hsgs.compiler.env.gen-sym env $ λ 'xhs. λ 'env1. either.for
            'p ← hsgs.compile-local-env (hsgs.compiler.env.var.insert f0 〈 '0 ∝ ordered-set.empty; '1 ∝ hsexpr.var xhs; 〉 env1) pos fvs1 envhs k;
        . right 〈
            '0 ∝ ordered-set.∪ hsimport.<=>
                (ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbclfield_w} : hspos-import : hsimport.var qq{GSI.Syn} qq{gsvar} : nil))
                (p #0)
            ;
            '1 ∝ hsexpr.applyvar qq{gsbclfield_w} (hspos pos : hsexpr.applyvar qq{gsvar} (hsexpr.string (gsvar.name f0) : nil) : hsexpr.var envhs : hsexpr.lambda xhs (p #1) : nil);
        〉
|]

$gsdeclare hsgs.compile-generator gshsgs_compile_generator

gshsgs_compile_generators = [gs:value| λ 'env. λ 'gs. λ 'pos1. analyze gs.
    case 'g:'gs1. either.for 'p0 ← hsgs.compile-generator env (g #pos) (g #gen);.
        hsgs.compiler.env.gen-sym env $ λ 'envhs. λ 'env1.
            either.for 'p1 ← hsgs.compile-generators env1 gs1 pos1;. right 〈
                '0 ∝ ordered-set.unions hsimport.<=> (
                    (ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbccomposegen_w} : hspos-import : hsimport.type qq{GSI.Value} qq{GSArg} : nil)) :
                    p0 #0 :
                    p1 #0 :
                    nil
                );
                '1 ∝ hsexpr.applyvar qq{gsbccomposegen_w} (hspos (g #pos) : hsexpr.applyvar qq{GSArgExpr} (hspos (g #pos) : p0 #1 : nil) : hsexpr.lambda envhs (p1 #1) : nil);
            〉
    case nil. right 〈
        '0 ∝ ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcemptygen_w} : hspos-import : nil);
        '1 ∝ hsexpr.app (hsexpr.var qq{gsbcemptygen_w}) (hspos pos1);
    〉
|]

$gsdeclare hsgs.compile-generator-app gshsgs_compile_generator_app

gshsgs_compile_generator = [gs:value| λ 'env. λ 'pos. λ 'g. analyze g.
    case generator.app 'g0 'pos1 'g1. hsgs.compile-generator-app env pos g0 (〈 '0 ∝ pos1; '1 ∝ g1; 〉 : nil)
|]

$gsdeclare hsgs.compile-generator-arg gshsgs_compile_generator_arg

gshsgs_compile_generator_app = [gs:value| λ 'env. λ 'pos. λ 'g. λ 'as. analyze g.
    case generator.var 'v. (analyze hsgs.compiler.env.var.get v (hsgs.compiler.env.generator.get env).
        case nothing. left $ pos.fmt pos qq{generator §(gsvar.fmt-atom v) not in scope}
        case just 'p. either.for 'as1 ← either.mapM (hsgs.compile-generator-arg env) as;. right 〈
            '0 ∝ ordered-set.unions hsimport.<=> (
                ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcapply_w} : hspos-import : nil) :
                p #0 :
                map (λ 'p1. p1 #0) as1 <>
                nil
            );
            '1 ∝ hsexpr.applyvar qq{gsbcapply_w} (hspos pos : p #1 : hsexpr.list (map (λ 'p1. p1 #1) as1) : nil);
        〉
    )
    case generator.app 'g0 'pos1 'g1. hsgs.compile-generator-app env pos g0 (〈 '0 ∝ pos1; '1 ∝ g1; 〉 : as)
|]

gshsgs_compile_generator_arg = [gs:value| λ 'env. λ 'a. for 'pos ∝ a#0;. analyze a #1.
    case generator.pattern 'p _. either.for 'r ← hsgs.compile-pat env pos p;. right 〈
        '0 ∝ ordered-set.∪ hsimport.<=>
            (ordered-set.from-list hsimport.<=> (hsimport.type qq{GSI.Value} qq{GSArg} : hspos-import : nil))
            (r #0)
        ;
        '1 ∝ hsexpr.applyvar qq{GSArgExpr} (hspos pos : r #1 : nil);
    〉
    case generator.expr (expr.var 'v). (analyze hsgs.compiler.env.var.get v env.
        case just 'p. right 〈
            '0 ∝ ordered-set.∪ hsimport.<=> (ordered-set.singleton (hsimport.type qq{GSI.Value} qq{GSArg})) (p #0);
            '1 ∝ hsexpr.app (hsexpr.var qq{GSArgVar}) (p #1);
        〉
    )
    case generator.expr (expr.natural 'n). right 〈
        '0 ∝ ordered-set.from-list hsimport.<=> (hsimport.type qq{GSI.Value} qq{GSArg} : hsimport.type qq{GSI.Value} qq{GSValue} : hspos-import : nil);
        '1 ∝ hsexpr.app (hsexpr.var qq{GSArgVar}) (hsexpr.app (hsexpr.var qq{GSNatural}) (hsexpr.int n));
    〉
    case generator.expr 'e. either.for 'p ← hsgs.compile-expr env pos e;. right 〈
        '0 ∝ ordered-set.∪ hsimport.<=>
            (ordered-set.from-list hsimport.<=> (hsimport.type qq{GSI.Value} qq{GSArg} : hspos-import : nil))
            (p #0)
        ;
        '1 ∝ hsexpr.applyvar qq{GSArgExpr} (hspos pos : p #1 : nil);
    〉
|]

gshsgs_compile_pat = [gs:value| λ 'env. λ 'pos. λ 'p. analyze p.
    case pat.discard. right 〈
        '0 ∝ ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcdiscardpattern_w} : hspos-import : nil);
        '1 ∝ hsexpr.applyvar qq{gsbcdiscardpattern_w} (hspos pos : nil);
    〉
    case pat.var 'v. right 〈
        '0 ∝ ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcvarpattern_w} : hspos-import : hsimport.var qq{GSI.Syn} qq{gsvar} : nil);
        '1 ∝ hsexpr.applyvar qq{gsbcvarpattern_w} (hspos pos : hsexpr.app (hsexpr.var qq{gsvar}) (hsexpr.string (gsvar.name v)) : nil);
    〉
|]

$gsdeclare hsgs.compile-fallible-pat-app gshsgs_compile_fallible_pat_app
$gsdeclare hsgs.compile-infallible-pat gshsgs_compile_infallible_pat

gshsgs_compile_fallible_pat = [gs:value| λ 'env. λ 'pos. λ 'p. analyze p.
    case pat.discard. hsgs.compile-infallible-pat env pos p
    case pat.var _. hsgs.compile-infallible-pat env pos p
    case pat.view 'v. (analyze hsgs.compiler.env.view.get v env.
        case nothing. left $ pos.fmt pos qq{view §(gsvar.fmt-atom v) not in scope}
        case just 'r. right 〈
            '0 ∝ ordered-set.inserts hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcviewpattern_w} : hspos-import : nil) $ r #0;
            '1 ∝ hsexpr.applyvar qq{gsbcviewpattern_w} (hspos pos : r #1 : hsexpr.list nil : nil);
        〉
    )
    case pat.app 'p0 'pos1 'p1. hsgs.compile-fallible-pat-app env pos p0 (〈 '0 ∝ pos1; '1 ∝ p1; 〉 : nil)
|]

gshsgs_compile_fallible_pat_app = [gs:value| λ 'env. λ 'pos. λ 'p. λ 'as. analyze p.
    case pat.app 'p0 'pos1 'p1. hsgs.compile-fallible-pat-app env pos p0 (〈 '0 ∝ pos1; '1 ∝ p1; 〉 : as)
    case pat.view 'v. (analyze hsgs.compiler.env.view.get v env.
        case nothing. left $ pos.fmt pos qq{view §(gsvar.fmt-atom v) not in scope}
        case just 'r. either.for 'ras ← either.mapM (λ 'a. either.for 'ra ← hsgs.compile-fallible-pat env (a #0) (a #1);. right 〈 'pos ∝ a #0; 'is ∝ ra #0; 'cp ∝ ra #1; 〉) as;. right 〈
            '0 ∝ ordered-set.unions hsimport.<=> (
                ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcviewpattern_w} : hspos-import : hsimport.type qq{GSI.Value} qq{GSArg} : nil) :
                r #0 :
                map (λ 'ra. ra #is) ras
            );
            '1 ∝ hsexpr.applyvar qq{gsbcviewpattern_w} (hspos pos : r #1 : hsexpr.list (map (λ 'ra. hsexpr.applyvar qq{GSArgExpr} (hspos (ra #pos) : ra #cp : nil)) ras) : nil);
        〉
    )
|]

gshsgs_compile_infallible_pat = [gs:value| λ 'env. λ 'pos. λ 'p. either.for 'r ← hsgs.compile-pat env pos p;. right 〈
    '0 ∝ ordered-set.inserts hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcapply_w} : hsimport.var qq{GSI.StdLib} qq{gsinfalliblepattern} : hsimport.type qq{GSI.Value} qq{GSArg} : hspos-import : nil) (r #0);
    '1 ∝ hsexpr.applyvar qq{gsbcapply_w} (hspos pos : hsexpr.var qq{gsinfalliblepattern} : hsexpr.list (hsexpr.applyvar qq{GSArgExpr} (hspos pos : r #1 : nil) : nil) : nil);
〉 |]

hspos_import = [gs:value| hsimport.type qq{GSI.Util} qq{Pos} |]

hspos = [gs:value| λ 'pos. hsexpr.applyvar qq{Pos} (hsexpr.string (pos #filename) : hsexpr.int (pos #line) : hsexpr.int (pos #col) : nil) |]
