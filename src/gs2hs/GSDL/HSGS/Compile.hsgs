module GSDL.HSGS.Compile (gshsgs_compile_value, gshsgs_compile_expr, gshsgs_compile_arg) where

$gsimports

gshsgs_compile_value = [gs:value| λ 'pos0. λ 'env. λ 'pos1. λ 'e. analyze e.
    case expr.var 'v. (analyze hsgs.compiler.env.constr.get v env.
        case false. (analyze hsgs.compiler.env.var.get v env.
            case just 'p. right p
        )
    )
    case _. either.for 'p ← hsgs.compile-expr env hsgs.compiler.supply.env.empty pos1 e;. right $
        hsoutput.app (hsoutput.ivar qq{System.IO.Unsafe} qq{unsafePerformIO}) $
            hsoutput.applyivarpos qq{GSI.Value} qq{gsthunk_w} pos0 (p : nil)
|]

$gsdeclare hsgs.compile-app gshsgs_compile_app
$gsdeclare hsgs.compile-custom-app gshsgs_compile_custom_app
$gsdeclare hsgs.compile-generators gshsgs_compile_generators
$gsdeclare hsgs.compile-monadic-generators gshsgs_compile_monadic_generators
$gsdeclare hsgs.compile-pat gshsgs_compile_pat
$gsdeclare hsgs.compile-fallible-pat gshsgs_compile_fallible_pat
$gsdeclare hsgs.compile-open-expr gshsgs_compile_open_expr

gshsgs_compile_expr = [gs:value| λ 'env. λ 'senv. λ 'pos. λ 'e. analyze e.
    case expr.natural 'n. right $ hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcnatural_w} pos (hsoutput.int n : nil)
    case expr.var 'v.
        (analyze hsgs.compiler.env.constr.get v env.
            case false. id
            case true. either.map (hsoutput.rehere pos)
        ) $
            (analyze hsgs.compiler.env.var.get v env.
                    case nothing. left $ pos.fmt pos qq{§(gsvar.fmt-atom v) not in scope}
                    case just 'p. right $ hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcenter_w} pos (p : nil)
                )
    case expr.structure-literal 'gs 'pos1. hsgs.compile-generators env gs pos1
    case expr.app 'f 'x. (analyze x.
        case arg.here. hsgs.compile-app env pos f (x : nil)
        case arg.expr _ _. hsgs.compile-app env pos f (x : nil)
        case arg.app 'af 'ax. hsgs.compile-custom-app env pos f af (ax : nil)
    )
    case expr.generators 'gs 'pos1. hsgs.compile-generators env gs pos1
    case expr.monadic-generators 'gs 'pos1. (analyze hsgs.compiler.supply.env.monad.get senv.
        case nothing. left $ pos.fmt pos qq{missing supply monad}
    )
    case expr.pat 'p _. hsgs.compile-pat env pos p
    case expr.fallible-pat 'p _. hsgs.compile-fallible-pat env pos p
    case expr.open-expr 'e (just 'fvs). hsgs.compile-open-expr env pos fvs e
    case expr.missing-case. hsgs.compiler.env.gen-sym env $ λ 'xhs. λ 'env1. right $
        hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcarg_w} pos (
            hsoutput.lambda xhs (
                hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcprim_w} pos
                    (hsoutput.ivar qq{GSI.CalculusPrims} qq{gspriminsufficientcases} : hsoutput.var xhs : nil)
            ) :
            nil
        )
|]

$gsdeclare need-here gsneed_here
$gsdeclare supply-here gssupply_here
$gsdeclare hsgs.compile-args gshsgs_compile_args

gshsgs_compile_app = [gs:value| λ 'env. λ 'pos. λ 'f. λ 'as. analyze f.
    case expr.var 'v. (analyze hsgs.compiler.env.constr.get v env.
        case false. (either.for
                'senv ← right $ hsgs.compiler.supply.env.empty;
                'p ← analyze hsgs.compiler.env.var.get v env.
                    case nothing. left $ pos.fmt pos qq{§(gsvar.fmt-atom v) not in scope}
                    case just 'p. right p
                ;
            . analyze need-here as.
                case false. hsgs.compile-args pos p as senv env
                case true. supply-here env senv pos (hsgs.compile-args pos p as)
        )
    )
    case expr.unary 'v. (either.for
            'senv ← right $ hsgs.compiler.supply.env.empty;
            'p ← analyze hsgs.compiler.env.var.get v (hsgs.compiler.env.unary.get env).
                case nothing. left $ pos.fmt pos qq{unary §(gsvar.fmt-atom v) not in scope}
                case just 'p. right p
            ;
        . analyze need-here as.
            case false. hsgs.compile-args pos p as senv env
            case true. supply-here env senv pos (hsgs.compile-args pos p as)
    )
    case expr.app 'f1 'a. hsgs.compile-app env pos f1 (a:as)
|]

-- To implement §gs{here}, we need to find the call stack for the whole application.
-- Check if that's needed and, if so, wrap the application in §hs{gsbcwithhere_w} and pass the call stack into §gs{hsgs.compile-arg}

gsneed_here = [gs:value| λ 'as. list.∃ (λ 'a. analyze a. case arg.here. true case _. false) as |]

gssupply_here = [gs:value|  λ 'env. λ 'senv. λ 'pos. λ 'k. hsgs.compiler.env.gen-sym env $ λ 'herehs. λ 'env1.
    for 'senv1 ∝ hsgs.compiler.supply.env.here.insert herehs senv;.
        either.for 'p1 ← k senv1 env1;.
            right $ hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcwithhere_w} pos (hsoutput.lambda herehs p1 : nil)
|]

gshsgs_compile_args = [gs:value| λ 'pos. λ 'p. λ 'as. λ 'senv. λ 'env1. either.for 'as1 ← either.mapM (hsgs.compile-arg senv env1) as;. right $
    hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcapply_w} pos (p : hsoutput.list as1 : nil)
|]

gshsgs_compile_custom_app = [gs:value| λ 'env. λ 'pos. λ 'f. λ 'af. λ 'as. analyze af.
    case arg.var 'v. (analyze hsgs.compiler.env.arg-var.get v env.
        case nothing. left $ pos.fmt pos qq{argument §(gsvar.fmt-atom v) not in scope}
        case just 'c. c env pos f as
    )
|]

gshsgs_compile_arg = [gs:value| λ 'senv. λ 'env. λ 'a. analyze a.
    case arg.expr 'pos (expr.var 'v). (analyze hsgs.compiler.env.constr.get v env.
        case false. (analyze hsgs.compiler.env.var.get v env.
            case nothing. left $ pos.fmt pos qq{§(gsvar.fmt-atom v) not in scope}
            case just 'p. right $ hsoutput.arg-var p
        )
    )
    case arg.expr 'pos (expr.value-var 'v). (analyze hsgs.compiler.env.var.get v env.
        case nothing. left $ pos.fmt pos qq{§(gsvar.fmt-atom v) not in scope}
        case just 'p. right $ hsoutput.arg-var p
    )
    case arg.expr 'pos 'e. either.for 'p ← hsgs.compile-expr env senv pos e;. right $ hsoutput.arg-expr pos p
    case arg.here. analyze hsgs.compiler.supply.env.here.get senv.
        case just 'here. right $ hsoutput.arg-var $ hsoutput.var here
|]

$gsdeclare hsgs.compile-local-env gshsgs_compile_local_env

gshsgs_compile_open_expr = [gs:value| λ 'env. λ 'pos. λ 'fvs. λ 'e. hsgs.compiler.env.gen-sym env $ λ 'envhs. λ 'env1. either.for
        'p ← hsgs.compile-local-env env1 pos fvs envhs $ λ 'env2. hsgs.compile-expr env2 hsgs.compiler.supply.env.empty pos e;
    . right $ hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcarg_w} pos (hsoutput.lambda envhs p : nil)
|]

gshsgs_compile_local_env = [gs:value| λ 'env. λ 'pos. λ 'fvs. λ 'envhs. λ 'k. analyze fvs.
    case nil. k env
    case 'f0:'fvs1. hsgs.compiler.env.gen-sym env $ λ 'xhs. λ 'env1. either.for
            'p ← hsgs.compile-local-env (hsgs.compiler.env.var.insert f0 (hsoutput.var xhs) env1) pos fvs1 envhs k;
        . right $ hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbclfield_w} pos (hsoutput.gsvar f0 : hsoutput.var envhs : hsoutput.lambda xhs p : nil)
|]

$gsdeclare hsgs.compile-generator gshsgs_compile_generator

gshsgs_compile_generators = [gs:value| λ 'env. λ 'gs. λ 'pos1. analyze gs.
    case 'g:'gs1. either.for 'p0 ← hsgs.compile-generator env (g #pos) (g #gen);.
        hsgs.compiler.env.gen-sym env $ λ 'envhs. λ 'env1.
            either.for 'p1 ← hsgs.compile-generators env1 gs1 pos1;. right $
                hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbccomposegen_w} (g #pos) (hsoutput.arg-expr (g #pos) p0 : hsoutput.lambda envhs p1 : nil)
    case nil. right $ hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcemptygen_w} pos1 nil
|]

gshsgs_compile_monadic_generators = [gs:value| λ 'env. λ 'senv. λ 'hsb. λ 'hsu. λ 'gs. λ 'pos1. analyze gs.
    case 'g:'gs1. either.for 'p0 ← hsgs.compile-generator env (g #pos) (g #gen);.
        hsgs.compiler.env.gen-sym env $ λ 'envhs. λ 'env1.
            either.for 'p1 ← hsgs.compile-monadic-generators env1 senv hsb hsu gs1 pos1;. right $
                hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbccomposemonadgen_w} (g #pos)
                    (hsoutput.arg-var hsb : hsoutput.arg-var hsu : hsoutput.arg-expr (g #pos) p0 : hsoutput.lambda envhs p1 : nil)
|]

$gsdeclare hsgs.compile-generator-app gshsgs_compile_generator_app

gshsgs_compile_generator = [gs:value| λ 'env. λ 'pos. λ 'g. analyze g.
    case generator.app 'g0 'pos1 'g1. hsgs.compile-generator-app env pos g0 (〈 '0 ∝ pos1; '1 ∝ g1; 〉 : nil)
|]

$gsdeclare hsgs.compile-generator-arg gshsgs_compile_generator_arg

gshsgs_compile_generator_app = [gs:value| λ 'env. λ 'pos. λ 'g. λ 'as. analyze g.
    case generator.var 'v. (analyze hsgs.compiler.env.var.get v (hsgs.compiler.env.generator.get env).
        case nothing. left $ pos.fmt pos qq{generator §(gsvar.fmt-atom v) not in scope}
        case just 'p. either.for 'as1 ← either.mapM (hsgs.compile-generator-arg env) as;. right $
            hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcapply_w} pos (p : hsoutput.list as1 : nil)
    )
    case generator.app 'g0 'pos1 'g1. hsgs.compile-generator-app env pos g0 (〈 '0 ∝ pos1; '1 ∝ g1; 〉 : as)
|]

gshsgs_compile_generator_arg = [gs:value| λ 'env. λ 'a. for 'pos ∝ a#0;. analyze a #1.
    case generator.pattern 'p _. either.for 'r ← hsgs.compile-pat env pos p;. right $ hsoutput.arg-expr pos r
    case generator.expr (expr.var 'v). (analyze hsgs.compiler.env.constr.get v env.
        case false. (analyze hsgs.compiler.env.var.get v env.
            case just 'p. right $ hsoutput.arg-var p
        )
    )
    case generator.expr (expr.natural 'n). right $
        hsoutput.arg-var $ hsoutput.app (hsoutput.iconstr qq{GSI.Value} qq{GSValue} qq{GSNatural}) (hsoutput.int n)
    case generator.expr 'e. either.for 'p ← hsgs.compile-expr env pos e;. right $ hsoutput.arg-expr p
|]

gshsgs_compile_pat = [gs:value| λ 'env. λ 'pos. λ 'p. analyze p.
    case pat.discard. right $ hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcdiscardpattern_w} pos nil
    case pat.var 'v. right $ hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcvarpattern_w} pos (hsoutput.gsvar v : nil)
|]

$gsdeclare hsgs.compile-fallible-pat-app gshsgs_compile_fallible_pat_app
$gsdeclare hsgs.compile-infallible-pat gshsgs_compile_infallible_pat

gshsgs_compile_fallible_pat = [gs:value| λ 'env. λ 'pos. λ 'p. analyze p.
    case pat.discard. hsgs.compile-infallible-pat env pos p
    case pat.var _. hsgs.compile-infallible-pat env pos p
    case pat.view 'v. (analyze hsgs.compiler.env.view.get v env.
        case nothing. left $ pos.fmt pos qq{view §(gsvar.fmt-atom v) not in scope}
        case just 'r. right $ hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcviewpattern_w} pos (r : hsoutput.list nil : nil)
    )
    case pat.app 'p0 'pos1 'p1. hsgs.compile-fallible-pat-app env pos p0 (〈 '0 ∝ pos1; '1 ∝ p1; 〉 : nil)
|]

gshsgs_compile_fallible_pat_app = [gs:value| λ 'env. λ 'pos. λ 'p. λ 'as. analyze p.
    case pat.app 'p0 'pos1 'p1. hsgs.compile-fallible-pat-app env pos p0 (〈 '0 ∝ pos1; '1 ∝ p1; 〉 : as)
    case pat.view 'v. (analyze hsgs.compiler.env.view.get v env.
        case nothing. left $ pos.fmt pos qq{view §(gsvar.fmt-atom v) not in scope}
        case just 'r. either.for 'ras ← either.mapM (λ 'a. either.for 'ra ← hsgs.compile-fallible-pat env (a #0) (a #1);. right 〈 'pos ∝ a #0; 'is ∝ ra #0; 'cp ∝ ra #1; 〉) as;. right $
            hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcviewpattern_w} pos (r : hsoutput.list (map (λ 'ra. hsoutput.arg-expr (ra #pos) 〈 '0 ∝ ra #is; '1 ∝ ra #cp; 〉) ras) : nil)
    )
|]

gshsgs_compile_infallible_pat = [gs:value| λ 'env. λ 'pos. λ 'p. either.for 'r ← hsgs.compile-pat env pos p;. right $
    hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcapply_w} pos
        (hsoutput.ivar qq{GSI.StdLib} qq{gsinfalliblepattern} : hsoutput.list (hsoutput.arg-expr pos r : nil) : nil)
|]
