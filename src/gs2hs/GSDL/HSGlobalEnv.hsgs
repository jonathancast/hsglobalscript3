module GSDL.HSGlobalEnv (gshsgs_parser_global_env, gshscompiler_global_env, gshscompiler_hsgs_global_env) where

$gsimports

gshsgs_parser_global_env = [gs:value|
    parser.env.assoc.insert (gsvar qq{:}) assoc.right $
    parser.env.else-needs-comma.set false $
    parser.global-env
|]

$gsdeclare hscompiler.env.supply.monad.simple-insert gshscompiler_env_supply_monad_simple_insert
$gsdeclare hscompiler.env.var.simple-insert gshscompiler_env_var_simple_insert
$gsdeclare hscompiler.env.view.simple-insert gshscompiler_env_view_simple_insert
$gsdeclare hscompile-qchar gshscompile_qchar

gshscompiler_global_env = [gs:value|
    hscompiler.env.constr.insert (gsvar qq{error}) $
    hscompiler.env.constr.insert (gsvar qq{undefined}) $
    hscompiler.env.constr.insert (gsvar qq{λ}) $
    hscompiler.env.constrarity.insert (gsvar qq{λ}) 2 $
    hscompiler.env.generator.modify (hscompiler.env.var.simple-insert (gsvar qq{←}) qq{GSI.StdLib} qq{gsfrom}) $
    hscompiler.env.generator.modify (hscompiler.env.var.simple-insert (gsvar qq{∝}) qq{GSI.StdLib} qq{gsmatch}) $
    hscompiler.env.supply.monad.simple-insert (gsvar qq{either.for}) qq{GSI.Either} qq{gseither_monad} $
    hscompiler.env.var.simple-insert (gsvar qq{+}) qq{GSI.Addition} qq{gsaddition_plus} $
    hscompiler.env.var.simple-insert (gsvar qq{>>=}) qq{GSI.Monad} qq{gsmonad_bind} $
    hscompiler.env.var.simple-insert (gsvar qq{analyzeM}) qq{GSI.StdLib} qq{gsanalyzeM} $
    hscompiler.env.var.simple-insert (gsvar qq{analyze}) qq{GSI.StdLib} qq{gsanalyze} $
    hscompiler.env.var.simple-insert (gsvar qq{case}) qq{GSI.StdLib} qq{gscase} $
    hscompiler.env.var.simple-insert (gsvar qq{either.for}) qq{GSI.Either} qq{gseither_for} $
    hscompiler.env.var.simple-insert (gsvar qq{false}) qq{GSI.Bool} qq{gsfalse} $
    hscompiler.env.var.simple-insert (gsvar qq{file.name.extension.get}) qq{GS.FileName} qq{gsfile_name_extension_get} $
    hscompiler.env.var.simple-insert (gsvar qq{file.name.in}) qq{GS.FileName} qq{gsfile_name_in} $
    hscompiler.env.var.simple-insert (gsvar qq{foldr}) qq{GSI.List} qq{gsfoldr} $
    hscompiler.env.var.simple-insert (gsvar qq{for}) qq{GSI.StdLib} qq{gsfor} $
    hscompiler.env.var.simple-insert (gsvar qq{gsio.dir.read}) qq{GSI.Env} qq{gsdir_read} $
    hscompiler.env.var.simple-insert (gsvar qq{gsio.file.stat}) qq{GSI.Env} qq{gsfile_stat} $
    hscompiler.env.var.simple-insert (gsvar qq{gsio.monad}) qq{GSI.GSIO} qq{gsio_monad} $
    hscompiler.env.var.simple-insert (gsvar qq{just}) qq{GSI.Maybe} qq{gsjust} $
    hscompiler.env.var.simple-insert (gsvar qq{log.fmt}) qq{GSI.Log} qq{gslog_fmt} $
    hscompiler.env.var.simple-insert (gsvar qq{mapM0}) qq{GSI.Monad} qq{gsmonad_mapM0} $
    hscompiler.env.var.simple-insert (gsvar qq{map}) qq{GSI.List} qq{gsmap} $
    hscompiler.env.var.simple-insert (gsvar qq{natural.addition}) qq{GSI.Natural} qq{gsnatural_addition} $
    hscompiler.env.var.simple-insert (gsvar qq{nil}) qq{GSI.List} qq{gsnil} $
    hscompiler.env.var.simple-insert (gsvar qq{not}) qq{GSI.Bool} qq{gsnot} $
    hscompiler.env.var.simple-insert (gsvar qq{print-error}) qq{GSI.Env} qq{gsprintError} $
    hscompiler.env.var.simple-insert (gsvar qq{right}) qq{GSI.Either} qq{gsright} $
    hscompiler.env.var.simple-insert (gsvar qq{true}) qq{GSI.Bool} qq{gstrue} $
    hscompiler.env.var.simple-insert (gsvar qq{undefined}) qq{GSI.StdLib} qq{gsundefined} $
    hscompiler.env.var.simple-insert (gsvar qq{value}) qq{GSI.StdLib} qq{gsvalue} $
    hscompiler.env.var.simple-insert (gsvar qq{λ}) qq{GSI.StdLib} qq{gslambda} $
    hscompiler.env.view.simple-insert (gsvar qq{:}) qq{GSI.List} qq{gscons_view} $
    hscompiler.env.view.simple-insert (gsvar qq{false}) qq{GSI.Bool} qq{gsfalse_view} $
    hscompiler.env.view.simple-insert (gsvar qq{just}) qq{GSI.Maybe} qq{gsjust_view} $
    hscompiler.env.view.simple-insert (gsvar qq{nil}) qq{GSI.List} qq{gsnil_view} $
    hscompiler.env.view.simple-insert (gsvar qq{nothing}) qq{GSI.Maybe} qq{gsnothing_view} $
    hscompiler.env.view.simple-insert (gsvar qq{right}) qq{GSI.Either} qq{gsright_view} $
    hscompiler.env.view.simple-insert (gsvar qq{true}) qq{GSI.Bool} qq{gstrue_view} $
    hscompiler.env.arg-var.insert (gsvar qq{#}) (λ 'env. λ 'pos. λ 'f. λ 'as. analyze as.
        case arg.var-name 'v : nil. either.for 'p ← hscompile-arg nothing env (arg.expr pos f);. right $
            hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcfield_w} pos (p : hsoutput.gsvar v : nil)
    ) $
    hscompiler.env.qlo.insert (gsvar qq{r}) (λ 'env. λ 'pos. λ 'qi. analyze qi.
        case qloitem.char 'r. right $ hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcchar_w} pos (hsoutput.char r : nil)
    ) $
    hscompiler.env.qlo.insert (gsvar qq{qq}) (λ 'env. λ 'pos. λ 'qs.
        either.map (hsoutput.applyivarpos qq{GSI.String} qq{gsbcstring_w} pos) $ either.map list.singleton $ either.map hsoutput.list $
            either.map (map (hsoutput.arg-expr pos)) $ either.mapM
                (λ 'qi. analyze qi.
                    case qloitem.char 'r. right $ hsoutput.applyivarpos qq{GSI.String} qq{gsbcstringlit_w} pos (hsoutput.string (r : nil) : nil)
                    case qloitem.qchar 'r. either.for 'r1 ← hscompile-qchar r;.
                        right $ hsoutput.applyivarpos qq{GSI.String} qq{gsbcstringlit_w} pos (hsoutput.string (r1 : nil) : nil)
                    case qloitem.interp 'pos 'e. hscompile-expr env hscompiler.supply.env.empty pos e
                )
                qs
    ) $
    hscompiler.env.qlo.insert (gsvar qq{log}) (λ 'env. λ 'pos. λ 'qs.
        either.map (hsoutput.applyivarpos qq{GSI.Log} qq{gsbclog_w} pos) $ either.map list.singleton $ either.map hsoutput.list $ either.mapM
            (for 'output-char ∝ λ 'ch. right $ hsoutput.arg-expr pos $ hsoutput.applyivarpos qq{GSI.Log} qq{gsbclogstring_w} pos (hsoutput.string (ch : nil) : nil);.
                λ 'qi. analyze qi.
                    case qloitem.char 'ch. output-char ch
                    case qloitem.qchar r{\\}. output-char r{\\}
                    case qloitem.qchar r{n}. output-char r{\n}
            )
            qs
    ) $
    hscompiler.env.pattern.modify (hscompiler.env.qlo.insert (gsvar qq{qq}) (λ 'env. λ 'pos. λ 'p. foldr
        (λ 'qi. λ 'k. either.for
                'ch1 ← analyze qi.
                    case qloitem.char 'ch. right ch
                    case qloitem.qchar 'ch. hscompile-qchar ch
                ;
                'p1 ← k;
            . right $ hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcviewpattern_w} pos (
                hsoutput.ivar qq{GSI.List} qq{gscons_view} :
                hsoutput.list (
                    hsoutput.arg-expr pos (hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcrunepattern_w} pos (hsoutput.char ch1 : nil)) :
                    hsoutput.arg-expr pos p1 :
                    nil
                ) :
                nil
            )
        )
        (analyze p #1.
            case nothing. right $ hsoutput.applyivarpos qq{GSI.ByteCode} qq{gsbcviewpattern_w} pos (
                hsoutput.ivar qq{GSI.List} qq{gsnil_view} :
                hsoutput.list nil :
                nil
            )
            case just (qloitem.interp 'pos1 'p). hscompile-fallible-pat env pos1 p
        )
        (p #0)
    )) $
    hscompiler.env.empty
|]

gshscompiler_hsgs_global_env = [gs:value|
    hscompiler.env.unary.modify (hscompiler.env.var.simple-insert (gsvar qq{+}) qq{GSI.Natural} qq{gsnatural_unary_plus}) $
    hscompiler.env.var.simple-insert (gsvar qq{+}) qq{GSI.Natural} qq{gsnatural_add} $
    hscompiler.env.var.simple-insert (gsvar qq{:}) qq{GSI.List} qq{gscons} $
    hscompiler.env.var.simple-insert (gsvar qq{≠}) qq{GSI.Rune} qq{gsrune_neq} $
    hscompiler.global-env
|]

gshscompiler_env_supply_monad_simple_insert = [gs:value| λ 'v. λ 'm. λ 'hsv. hscompiler.env.supply.monad.insert v (hsoutput.ivar m hsv) |]
gshscompiler_env_var_simple_insert = [gs:value| λ 'v. λ 'm. λ 'hsv. hscompiler.env.var.insert v (hsoutput.ivar m hsv) |]
gshscompiler_env_view_simple_insert = [gs:value| λ 'v. λ 'm. λ 'hsv. hscompiler.env.view.insert v (hsoutput.ivar m hsv) |]

gshscompile_qchar = [gs:value| λ 'r. analyze r.
    case r{n}. right r{\n}
    case r{\[}. right r{\[}
|]
