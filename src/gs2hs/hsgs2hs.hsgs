{-# LANGUAGE TemplateHaskell #-}

import GSI.Env (runGSProgram)
$gsimports

$gsdeclare process-arg gsprocess_arg

main = runGSProgram $ [gs:value| λ 'as. impmapM process-arg as |]

$gsdeclare need-to-recompile gsneed_to_recompile
$gsdeclare compile-hsgs-source gscompile_hsgs_source
$gsdeclare mk-hs-file gsmk_hs_file

gsprocess_arg = [gs:value| λ 'a. impanalyzeM file.stat a.
    case left (ENOENT _). impfor _ ← print-error qq{§(a): Could not load: no such file or directory\n};. abend qq{enoent}
    case right 'st. (analyze st #is.dir.
        case true. impfor 'as ← dir.read a;. impmapM (λ 'a1. process-arg (a <> r{/} : a1)) as
        case false. (analyze list.≡ rune.≡ (file.name.extension.get a) qq{hsgs}.
            case true. (impanalyzeM need-to-recompile a.
                case true. (impfor 's ← file.read a;. analyze compile-hsgs-source a s.
                    case right 's1. file.write (mk-hs-file a) s1
                    case left 'err. impfor _ ← print-error qq{§(err)\n};. abend qq{compile-error}
                )
            )
        )
    )
|]

gsneed_to_recompile = [gs:value| λ 'a. impanalyzeM file.stat a.
    case right 'st.gs. (impanalyzeM file.stat (mk-hs-file a).
        case left (ENOENT _). impunit true
        case right 'st.hs. impunit (rational.> (st.gs #mod.time) (st.hs #mod.time))
    )
|]

gsmk_hs_file = [gs:value| file.name.extension.set qq{hs} |]

$gsdeclare split-input gssplit_input
$gsdeclare compile-source gscompile_source
$gsdeclare hsgs.compiler.global-env gshsgs_compiler_global_env
$gsdeclare format-output gsformat_output
$gsdeclare hsstring hsstring

gscompile_hsgs_source = [gs:value| λ 'fn. λ 's. either.for
        'i ← split-input (pos.init fn) s;
        'c ← compile-source i hsgs.compiler.global-env;
    . right qq{{-# LINE 1 §(hsstring fn) #-}\n§(format-output c)}
|]

gssplit_input = [gs:value| λ 'pos. λ 's. analyze s.
    case r{$}:'s1. (analyze parse-partial advance-rune print-rune (interpolation (parser.env.else-needs-comma.set false parser.global-env)) (advance-rune r{$} pos) s1.
        case left _. either.map ((:) (source-comp.char r{$})) (split-input (advance-rune r{$} pos) s1)
        case right 'r. either.map ((:) (r #0) ∘ (:) (source-comp.pos (r #1))) (split-input (r #1) (r #2))
    )
    case qq{\[gs:§('s1)}. either.for 'r ← parse-partial advance-rune print-rune (quote (parser.env.else-needs-comma.set false parser.global-env) pos <* string qq{|\]}) (advance-string qq{\[gs:} pos) s1;.
        either.map ((:) (r #0) ∘ (:) (source-comp.pos (r #1))) (split-input (r #1) (r #2))
    case 'c:'s1. either.map ((:) (source-comp.char c)) (split-input (advance-rune c pos) s1)
    case nil. right nil
|]

$gsdeclare process-params gsprocess_params
$gsdeclare compile-value gscompile_value
$gsdeclare compile-expr gscompile_expr

gscompile_source = [gs:value| λ 'i. λ 'env. analyze i.
    case source-comp.char 'c : 'i1. either.map ((:) (dest-comp.char c)) (compile-source i1 env)
    case source-comp.imports : 'i1. either.map ((:) dest-comp.imports) (compile-source i1 env)
    case source-comp.declare 'gsv 'hsv : 'i1. compile-source i1 (hsgs.compiler.env.var.insert gsv 〈 '0 ∝ ordered-set.empty; '1 ∝ hsexpr.var hsv; 〉 env)
    case source-comp.pos 'pos : 'i1. either.map ((:) (dest-comp.pos pos)) (compile-source i1 env)
    case source-comp.value 'pos0 'ps 'pos1 'e : 'i1. either.for
            'ea ← right $ annotate-expr annotator.global-env e;
            'ei ← right $ add-implicits-expr type-checker.global-env ea;
            'p ← compile-value pos0 (process-params ps env) pos1 ei;
            'o1 ← compile-source i1 env;.
        right (dest-comp.expr (p #0) (p #1) : o1)
    case source-comp.expr 'ps 'pos 'e : 'i1. either.for
            'ea ← right $ annotate-expr annotator.global-env e;
            'ei ← right $ add-implicits-expr type-checker.global-env ea;
            'p ← compile-expr (process-params ps env) pos ei;
            'o1 ← compile-source i1 env;.
        right (dest-comp.expr (p #0) (p #1) : o1)
    case nil. right nil
|]

gsprocess_params = [gs:value| λ 'ps. λ 'env. foldr
    (λ 'p. λ 'env. analyze p.
        case quote-param.hsvs 'vs.
            foldr (λ 'v. λ 'env₁. hsgs.compiler.env.var.insert v 〈 '0 ∝ ordered-set.empty; '1 ∝ hsexpr.var (gsvar.name v); 〉 env₁) env vs
    )
    env
    ps
|]

$gsdeclare hspos hspos
$gsdeclare hspos-import hspos_import

gscompile_value = [gs:value| λ 'pos0. λ 'env. λ 'pos1. λ 'e. analyze e.
    case expr.var 'v. (analyze hsgs.compiler.env.var.get v env.
        case just 'p. right p
    )
    case _. either.for 'p ← compile-expr env pos1 e;. right 〈
        '0 ∝ ordered-set.∪ hsimport.<=>
            (ordered-set.from-list hsimport.<=> (hsimport.var qq{System.IO.Unsafe} qq{unsafePerformIO} : hsimport.var qq{GSI.Value} qq{gsthunk_w} : hspos-import : nil))
            (p #0)
        ;
        '1 ∝ hsexpr.applyvar qq{unsafePerformIO} (hsexpr.applyvar qq{gsthunk_w} (hspos pos0 : p #1 : nil) : nil);
    〉
|]

$gsdeclare compile-app gscompile_app
$gsdeclare compile-pat gscompile_pat
$gsdeclare compile-fallible-pat gscompile_fallible_pat
$gsdeclare compile-open-expr gscompile_open_expr

gscompile_expr = [gs:value| λ 'env. λ 'pos. λ 'e. analyze e.
    case expr.natural 'n. right 〈
        '0 ∝ ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcnatural_w} : hspos-import : nil);
        '1 ∝ hsexpr.applyvar qq{gsbcnatural_w} (hspos pos : hsexpr.int n : nil);
    〉
    case expr.var 'v. (analyze hsgs.compiler.env.var.get v env.
        case nothing. left $ pos.fmt pos qq{§(gsvar.name v) not in scope}
        case just 'p. right 〈
            '0 ∝ ordered-set.∪ hsimport.<=>
                (ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcenter_w} : hspos-import : nil))
                (p #0)
            ;
            '1 ∝ hsexpr.applyvar qq{gsbcenter_w} (hspos pos : p #1 : nil);
        〉
    )
    case expr.app 'f 'x. compile-app env pos f (x : nil)
    case expr.pat 'p _. compile-pat env pos p
    case expr.fallible-pat 'p _. compile-fallible-pat env pos p
    case expr.open-expr 'e (just 'fvs). compile-open-expr env pos fvs e
    case expr.missing-case. hsgs.compiler.env.gen-sym env $ λ 'xhs. λ 'env1. right 〈
        '0 ∝ ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcarg_w} : hspos-import : hsimport.var qq{GSI.ByteCode} qq{gsbcprim_w} : hspos-import : hsimport.var qq{GSI.CalculusPrims} qq{gspriminsufficientcases} : nil);
        '1 ∝ hsexpr.applyvar qq{gsbcarg_w} (hspos pos : hsexpr.lambda xhs (hsexpr.applyvar qq{gsbcprim_w} (hspos pos : hsexpr.var qq{gspriminsufficientcases} : hsexpr.var xhs : nil)) : nil);
    〉
|]

$gsdeclare compile-arg gscompile_arg

gscompile_app = [gs:value| λ 'env. λ 'pos. λ 'f. λ 'as. analyze f.
    case expr.var 'v. (analyze hsgs.compiler.env.var.get v env.
        case nothing. left $ pos.fmt pos qq{§(gsvar.name v) not in scope}
        case just 'p.
            -- To implement §gs{here}, we need to find the call stack for the whole implementation.
            -- Check if that's needed and, if so, wrap the application in §hs{gsbcwithhere_w} and pass the call stack into §gs{compile-arg}
            (analyze list.∃ (λ 'a. analyze a. case arg.here. true case _. false) as.
                case false. λ 'k. k nothing env
                case true. λ 'k. hsgs.compiler.env.gen-sym env $ λ 'herehs. λ 'env1. either.for 'p1 ← k (just herehs) env1;.
                    right 〈
                        '0 ∝ ordered-set.inserts hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcwithhere_w} : hspos-import : nil) (p1 #0);
                        '1 ∝ hsexpr.applyvar qq{gsbcwithhere_w} (hspos pos : hsexpr.lambda herehs (p1 #1) : nil);
                    〉
            ) $ λ 'mbhere. λ 'env1. either.for 'as1 ← either.mapM (compile-arg mbhere env1) as;. right 〈
                '0 ∝ foldr (ordered-set.∪ hsimport.<=>) ordered-set.empty (
                    ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcapply_w} : hspos-import : nil) :
                    p #0 :
                    map (λ 'p1. p1 #0) as1 <>
                    nil
                );
                '1 ∝ hsexpr.applyvar qq{gsbcapply_w} (hspos pos : p #1 : hsexpr.list (map (λ 'p1. p1 #1) as1) : nil);
            〉
    )
    case expr.app 'f1 'a. compile-app env pos f1 (a:as)
|]

gscompile_arg = [gs:value| λ 'mbhere. λ 'env. λ 'a. analyze a.
    case arg.expr 'pos (expr.var 'v). (analyze hsgs.compiler.env.var.get v env.
        case nothing. left $ pos.fmt pos qq{§(gsvar.name v) not in scope}
        case just 'p. right 〈
            '0 ∝ ordered-set.∪ hsimport.<=> (ordered-set.singleton (hsimport.type qq{GSI.Value} qq{GSArg})) (p #0);
            '1 ∝ hsexpr.app (hsexpr.var qq{GSArgVar}) (p #1);
        〉
    )
    case arg.expr 'pos 'e. either.for 'p ← compile-expr env pos e;. right 〈
        '0 ∝ ordered-set.∪ hsimport.<=>
            (ordered-set.from-list hsimport.<=> (hsimport.type qq{GSI.Value} qq{GSArg} : hspos-import : nil))
            (p #0)
        ;
        '1 ∝ hsexpr.applyvar qq{GSArgExpr} (hspos pos : p #1 : nil);
    〉
    case arg.here. right 〈
        '0 ∝ ordered-set.from-list hsimport.<=> (hsimport.type qq{GSI.Value} qq{GSArg} : nil);
        '1 ∝ hsexpr.applyvar qq{GSArgVar} (hsexpr.var (analyze mbhere. case just 'here. here) : nil);
    〉
|]

$gsdeclare compile-local-env gscompile_local_env

gscompile_open_expr = [gs:value| λ 'env. λ 'pos. λ 'fvs. λ 'e. hsgs.compiler.env.gen-sym env $ λ 'envhs. λ 'env1. either.for
        'p ← compile-local-env env1 pos fvs envhs $ λ 'env2. compile-expr env2 pos e;
    . right 〈
        '0 ∝ ordered-set.∪ hsimport.<=>
            (ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcarg_w} : hspos-import : nil))
            (p #0)
        ;
        '1 ∝ hsexpr.applyvar qq{gsbcarg_w} (hspos pos : hsexpr.lambda envhs (p #1) : nil);
    〉
|]

gscompile_local_env = [gs:value| λ 'env. λ 'pos. λ 'fvs. λ 'envhs. λ 'k. analyze fvs.
    case nil. k env
    case 'f0:'fvs1. hsgs.compiler.env.gen-sym env $ λ 'xhs. λ 'env1. either.for
            'p ← compile-local-env (hsgs.compiler.env.var.insert f0 〈 '0 ∝ ordered-set.empty; '1 ∝ hsexpr.var xhs; 〉 env1) pos fvs1 envhs k;
        . right 〈
            '0 ∝ ordered-set.∪ hsimport.<=>
                (ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbclfield_w} : hspos-import : hsimport.var qq{GSI.Syn} qq{gsvar} : nil))
                (p #0)
            ;
            '1 ∝ hsexpr.applyvar qq{gsbclfield_w} (hspos pos : hsexpr.applyvar qq{gsvar} (hsexpr.string (gsvar.name f0) : nil) : hsexpr.var envhs : hsexpr.lambda xhs (p #1) : nil);
        〉
|]

gscompile_pat = [gs:value| λ 'env. λ 'pos. λ 'p. analyze p.
    case pat.discard. right 〈
        '0 ∝ ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcdiscardpattern_w} : hspos-import : nil);
        '1 ∝ hsexpr.applyvar qq{gsbcdiscardpattern_w} (hspos pos : nil);
    〉
    case pat.var 'v. right 〈
        '0 ∝ ordered-set.from-list hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcvarpattern_w} : hspos-import : hsimport.var qq{GSI.Syn} qq{gsvar} : nil);
        '1 ∝ hsexpr.applyvar qq{gsbcvarpattern_w} (hspos pos : hsexpr.app (hsexpr.var qq{gsvar}) (hsexpr.string (gsvar.name v)) : nil);
    〉
|]

$gsdeclare compile-infallible-pat gscompile_infallible_pat

gscompile_fallible_pat = [gs:value| λ 'env. λ 'pos. λ 'p. analyze p.
    case pat.discard. compile-infallible-pat env pos p
    case pat.var _. compile-infallible-pat env pos p
    case pat.view 'v. (analyze hsgs.compiler.env.view.get v env.
        case nothing. left $ pos.fmt pos qq{view §(gsvar.name v) not in scope}
        case just 'r. right 〈
            '0 ∝ ordered-set.inserts hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcviewpattern_w} : hspos-import : nil) $ r #0;
            '1 ∝ hsexpr.applyvar qq{gsbcviewpattern_w} (hspos pos : r #1 : hsexpr.list nil : nil);
        〉
    )
|]

gscompile_infallible_pat = [gs:value| λ 'env. λ 'pos. λ 'p. either.for 'r ← compile-pat env pos p;. right 〈
    '0 ∝ ordered-set.inserts hsimport.<=> (hsimport.var qq{GSI.ByteCode} qq{gsbcapply_w} : hsimport.var qq{GSI.StdLib} qq{gsinfalliblepattern} : hsimport.type qq{GSI.Value} qq{GSArg} : hspos-import : nil) (r #0);
    '1 ∝ hsexpr.applyvar qq{gsbcapply_w} (hspos pos : hsexpr.var qq{gsinfalliblepattern} : hsexpr.list (hsexpr.applyvar qq{GSArgExpr} (hspos pos : r #1 : nil) : nil) : nil);
〉 |]

$gsdeclare gather-imports gsgather_imports

gsformat_output = [gs:value| λ 'o. analyze o.
    case dest-comp.char 'c : 'o1. c : format-output o1
    case dest-comp.pos 'pos : 'o1. qq{\n{-# LINE §(fmt-decimal (pos #line)) §(hsstring (pos #filename)) #-}\n§(replicate (pos #col - 1) r{ })§(format-output o1)}
    case dest-comp.imports : 'o1. foldr hsimport.fmt (format-output o1) (ordered-set.to-list (gather-imports o1))
    case dest-comp.expr _ 'e : 'o1. hsexpr.fmt-atom e (format-output o1)
    case nil. nil
|]

gsgather_imports = [gs:value|
    foldl (ordered-set.∪ hsimport.<=>) ordered-set.empty ∘ map (λ 'o. analyze o.
        case dest-comp.char _. ordered-set.empty
        case dest-comp.pos _. ordered-set.empty
        case dest-comp.expr 'is _. is
    )
|]

hspos_import = [gs:value| hsimport.type qq{GSI.Util} qq{Pos} |]

hspos = [gs:value| λ 'pos. hsexpr.applyvar qq{Pos} (hsexpr.string (pos #filename) : hsexpr.int (pos #line) : hsexpr.int (pos #col) : nil) |]

hsstring = [gs:value| λ 's. qq{"§(s)"} |]

$gsdeclare hsgs.compiler.env.var.simple-insert gshsgs_compiler_env_var_simple_insert

gshsgs_compiler_global_env = [gs:value|
    hsgs.compiler.env.var.simple-insert (gsvar qq{analyze}) qq{GSI.StdLib} qq{gsanalyze} $
    hsgs.compiler.env.var.simple-insert (gsvar qq{case}) qq{GSI.StdLib} qq{gscase} $
    hsgs.compiler.env.var.simple-insert (gsvar qq{map}) qq{GSI.List} qq{gsmap} $
    hsgs.compiler.env.var.simple-insert (gsvar qq{not}) qq{GSI.Bool} qq{gsnot} $
    hsgs.compiler.env.var.simple-insert (gsvar qq{true}) qq{GSI.Bool} qq{gstrue} $
    hsgs.compiler.env.var.simple-insert (gsvar qq{undefined}) qq{GSI.StdLib} qq{gsundefined} $
    hsgs.compiler.env.var.simple-insert (gsvar qq{λ}) qq{GSI.StdLib} qq{gslambda} $
    hsgs.compiler.env.empty
|]

gshsgs_compiler_env_var_simple_insert = [gs:value| λ 'v. λ 'm. λ 'hsv. hsgs.compiler.env.var.insert v 〈 '0 ∝ ordered-set.singleton (hsimport.var m hsv); '1 ∝ hsexpr.var hsv; 〉 |]
