{-# LANGUAGE TemplateHaskell #-}

import GSI.Env (runGSProgram)
import GSI.Value (gslambda_value, gsav)
import GSI.ByteCode (gsbcarg, gsbcconstr, gsbcconstr_view)
$gsimports

$gsdeclare process-arg gsprocess_arg

main = runGSProgram $ [gs:value| λ 'as. impmapM process-arg as |]

$gsdeclare need-to-recompile gsneed_to_recompile
$gsdeclare compile-hsgs-source gscompile_hsgs_source
$gsdeclare mk-hs-file gsmk_hs_file

gsprocess_arg = [gs:value| λ 'a. impanalyzeM file.stat a.
    case left (ENOENT _). impfor _ ← print-error qq{§(a): Could not load: no such file or directory\n};. abend qq{enoent}
    case right 'st. (analyze st #is.dir.
        case true. impfor 'as ← dir.read a;. impmapM (λ 'a1. process-arg (a <> r{/} : a1)) as
        case false. (analyze list.≡ rune.≡ (file.name.extension.get a) qq{hsgs}.
            case true. (impanalyzeM need-to-recompile a.
                case true. (impfor 's ← file.read a;. analyze compile-hsgs-source a s.
                    case right 's1. file.write (mk-hs-file a) s1
                    case left 'err. impfor _ ← print-error qq{§(err)\n};. abend qq{compile-error}
                )
            )
        )
    )
|]

gsneed_to_recompile = [gs:value| λ 'a. impanalyzeM file.stat a.
    case right 'st. (impanalyzeM file.stat (mk-hs-file a).
        case left (ENOENT _). impunit true
    )
|]

gsmk_hs_file = [gs:value| file.name.extension.set qq{hs} |]

$gsdeclare split-input gssplit_input
$gsdeclare compile-source gscompile_source
$gsdeclare format-output gsformat_output
$gsdeclare hsstring hsstring

gscompile_hsgs_source = [gs:value| λ 'fn. λ 's. either.for
        'i ← split-input (pos.init fn) s;
        'c ← compile-source i;
        's1 ← format-output c;
    . right $ concat $ qq{{-# LINE 1 §(hsstring fn) #-}\n} : s1
|]

$gsdeclare source-comp.char gssource_comp_char

gssplit_input = [gs:value| λ 'pos. λ 's. analyze s.
    case qq{\[gs:§('s1)}. (analyze parse-partial advance-rune print-rune (quote parser.global-env <* string qq{|\]}) (advance-string qq{\[gs:} pos) s.
    )
    case 'c:'s1. either.map ((:) (source-comp.char c)) (split-input (advance-rune c pos) s1)
    case nil. right nil
|]

$gsdeclare view source-comp.char gssource_comp_char_view

$gsdeclare dest-comp.char gsdest_comp_char

gscompile_source = [gs:value| λ 'i. analyze i.
    case source-comp.char 'c : 'i1. either.map ((:) (dest-comp.char c)) (compile-source i1)
    case nil. right nil
|]

$gsdeclare view dest-comp.char gsdest_comp_char_view

gsformat_output = [gs:value| λ 'o. analyze o.
    case dest-comp.char 'c : 'o1. either.map ((:) (c : nil)) (format-output o1)
    case nil. right nil
|]

hsstring = [gs:value| λ 's. qq{"§(s)"} |]

gssource_comp_char = $gslambda_value $ \ ch -> $gsbcconstr (gsvar "char") [ $gsav ch ]

gssource_comp_char_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ sc -> $gsbcconstr_view "char" ek sk sc

gsdest_comp_char = $gslambda_value $ \ ch -> $gsbcconstr (gsvar "char") [ $gsav ch ]

gsdest_comp_char_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ sc -> $gsbcconstr_view "char" ek sk sc
