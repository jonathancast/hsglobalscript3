{-# LANGUAGE TemplateHaskell #-}

import Control.Concurrent.MVar (newMVar)
import Control.Exception (SomeException, catch, displayException)

import System.Environment (getArgs)
import System.Exit (ExitCode(..), exitWith)
import System.IO (hPutStrLn, stderr)

import GSI.Util (gsfatal, gshere)
import GSI.Value (gslambda_value, gsapply, gsundefined_value, gsav, gsae)
import GSI.Thread (createThread, execMainThread)
import GSI.Functions (gslist, gsstring)
import GSI.ByteCode (gsbcarg, gsbcapply, gsbcimpfor, gsbcimpbind, gsbcimpbody)
import GSI.Env (GSEnvArgs(..))
import GSI.GSI (GSIThread(..), gsiThreadData)
import GSI.Main (gsmain)
$gsimports

main = do
    as <- $gslist . map $gsstring <$> getArgs
    asmv <- newMVar $ GSEnvArgs $ as
    prog <- $gsapply gsmain [gstyc, gsrun, as]
    t <- createThread $gshere (gsiThreadData GSIThread{ envArgs = asmv }) prog Nothing
    execMainThread t
  `catch` \ e -> hPutStrLn stderr (displayException (e :: SomeException)) >> exitWith (ExitFailure 1) -- Because Haskell is a conspiracy to avoid good error messages

gstyc = [gs:value| λ 'pos. λ 'ty. type-checker.for
    . type-checker.unify pos ty (
        type.function (type.app (type.const (gsvar qq{list.t})) $ type.app (type.const (gsvar qq{list.t})) $ type.const (gsvar qq{rune.t})) $
            type.app (type.const (gsvar qq{gsi.m})) type.empty-signature
    )
|]

gsrun = $gslambda_value $ \ prog -> $gsbcarg $ \ args -> $gsbcimpfor $ do
    td <- [gs:bind hsvs=args,| gsiThreadData args |]
    p <- [gs:bind hsvs=prog,args,| gsapply prog (gsinject args : nil) |]
    t <- [gs:bind hsvs=td,p,| createThread td p |]
    [gs:body hsvs=t,| execMainThread t |]
