{-# LANGUAGE TemplateHaskell #-}
module GSI.Log (gsbclog, gsbclog_w, gsbclogstring, gsbclogstring_w, gslog_str, gslog_dstr, gsloggsv, gslog_fmt) where

import Language.Haskell.TH.Lib (varE, appE)

import GSI.Util (Pos, gshere)
import GSI.Syn (gsvar)
import GSI.Value (GSValue(..), GSExpr, GSArg, gslambda_value, gsundefined_value, gsae, gsav)
import GSI.ByteCode (gsbcarg, gsbcenter, gsbcapply, gsbcapply_w, gsbcconstr, gsbcrecord, gsbclfield)
import GSI.StdLib (gscompose)
import GSI.List (gscons)
$gsimports

gsbclog = varE 'gsbclog_w `appE` gshere

gsbclog_w :: Pos -> [GSArg] -> GSExpr
gsbclog_w pos as = foldr (\ a k -> gsbcapply_w pos gscompose [ a, $gsae k ]) ($gsbcenter gslogempty) as

gslogempty = [gs:value| λ 'k. k |]

gslog_dstr = [gs:value| λ 'ds. log.str (ds nil) |]

gslog_str = [gs:value| λ 's. foldr log.<> log.nil $ map log.char s |]

$gsdeclare paragraph-constituent.char gsparagraph_constituent_char

gslogchar = [gs:value| λ 'ch. λ 'k.
    〈 'paragraph-constituents ∝ paragraph-constituent.char ch : k #paragraph-constituents; 〉
|]

$gsdeclare paragraph-constituent.gsv gsparagraph_constituent_gsv

gsloggsv = [gs:value| λ 'x. λ 'k.
    〈 'paragraph-constituents ∝ paragraph-constituent.gsv x : k #paragraph-constituents; 〉
|]

gsbclogstring = varE 'gsbclogstring_w `appE` gshere

gsbclogstring_w :: Pos -> String -> GSExpr
gsbclogstring_w pos s = foldr (\ ch k -> gsbcapply_w pos gscompose [ $gsae $ gsbcapply_w pos gslogchar [$gsav $ GSRune ch], $gsae k ]) ($gsbcenter gslogempty) s

gslog_fmt = $gsundefined_value

gsparagraph_constituent_char = $gslambda_value $ \ ch -> $gsbcconstr (gsvar "char") [ $gsav ch ]
gsparagraph_constituent_gsv = $gslambda_value $ \ x -> $gsbcconstr (gsvar "gsv") [ $gsav x ]
