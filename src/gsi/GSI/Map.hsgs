{-# LANGUAGE TemplateHaskell #-}
module GSI.Map (gsordered_map_insert, gsordered_map_get, gsordered_map_keys, gsordered_map_values, gsordered_map_to_list, gsordered_map_empty, gsordered_map_empty_view) where

import GSI.Syn (gsvar)
import GSI.Value (gslambda_value, gsconstr, gsav)
import GSI.ByteCode (gsbcarg, gsbcconstr, gsbcconstr_view)
$gsimports

$gsdeclare prim.empty gsordered_map_empty
$gsdeclare prim.branch gsordered_map_prim_branch

$gsdeclare view empty gsordered_map_empty_view
$gsdeclare view branch gsordered_map_branch_view

gsordered_map_insert = [gs:value| λ 'cmp. λ 'k. λ 'v. λ 'm. analyze m.
    case empty. prim.branch k v prim.empty prim.empty
    case branch 'k1 'v1 'l 'r. (analyze cmp k k1.
        case lt. prim.branch k1 v1 (ordered-map.insert cmp k v l) r
        case gt. prim.branch k1 v1 l (ordered-map.insert cmp k v r)
    )
|]

gsordered_map_get = [gs:value| λ 'cmp. λ 'k. λ 'm. analyze m.
    case empty. nothing
    case branch 'k1 'v1 'l 'r. (analyze cmp k k1.
        case lt. ordered-map.get cmp k l
        case eq. just v1
        case gt. ordered-map.get cmp k r
    )
|]

gsordered_map_keys = [gs:value| λ 'm. analyze m.
|]

gsordered_map_values = [gs:value| λ 'm. analyze m.
    case branch _ _ 'l 'r. ordered-map.values l <> ordered-map.values r
    case empty. nil
|]

gsordered_map_to_list = [gs:value| λ 'm. analyze m.
    case branch 'k 'v 'l 'r. ordered-map.to-list l <> 〈 '0 ∝ k; '1 ∝ v; 〉 : ordered-map.to-list r
    case empty. nil
|]

gsordered_map_empty = $gsconstr (gsvar "empty") []
gsordered_map_prim_branch = $gslambda_value $ \ k -> $gsbcarg $ \ v -> $gsbcarg $ \ l -> $gsbcarg $ \ r -> $gsbcconstr (gsvar "branch") [ $gsav k, $gsav v, $gsav l, $gsav r ]

gsordered_map_empty_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "empty" ek sk e
gsordered_map_branch_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "branch" ek sk e
