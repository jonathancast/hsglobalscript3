{-# LANGUAGE TemplateHaskell #-}
module GSI.Main (gsmain) where

$gsimports

$gsdeclare gsprocessargs gsprocessargs

-- Main function (call this to start your interpreter)
gsmain = [gs:value| λ 'gstyc. λ 'gsrun. impfor 'args ← env.get-args;. gsprocessargs args gstyc gsrun |]

$gsdeclare parser.global-env gsparser_global_env
$gsdeclare process-document gsprocessDocument

-- Loops over arguments to process them
gsprocessargs = [gs:value| λ 'args. λ 'gstyc. λ 'gsrun. analyze args.
    case 'a : 'as. analyze-impM file.stat a.
        case left 'e. (analyze e.
            case ENOENT 'fn.
                impfor
                    _ ← print-error qq{§(a): Could not load: no such file or directory\n};
                  . error log{Process §(gsv a) (§(gsv e)) next}
        )
        case right 'st. (analyze st #is.dir.
            case true. gsprocessargs as gstyc gsrun -- Ignore all arguments until we start failing tests for it
            case false. impfor 's ← file.read a;. (analyze parse advance-rune print-rune (file parser.global-env) 〈 'filename ∝ a; 'line ∝ 1; 'col ∝ 1; 〉 s.
                case left 'err. impfor
                    _ ← print-error qq{§(err)\n};
                  . error log{§(gsv a): process §(gsv err) next}
                case right 'd. (analyze d.
                    case file.document 'pos 'mb. (analyze process-document pos gstyc mb.
                        case left 'err. impfor
                                _ ← print-error qq{§(err)\n};
                            . error log{Errors next}
                        case right 'prog. impfor 'progv ← gsthunk pos prog;. gsrun progv as
                    )
                )
            )
        )
|]

$gsdeclare type-checker.global-env gstype_checker_global_env

$gsdeclare compiler.global-env gscompiler_global_env

gsprocessDocument = [gs:value| λ 'pos. λ 'gstyc. λ 'mbe.
    either.for
        'mbe1 ← type-checker.run (type-check.document pos gstyc mbe) type-checker.global-env;
    . right (compile-document pos compiler.global-env mbe1)
|]

gsparser_global_env = [gs:value| parser.env.empty |]

$gsdeclare type-checker.gstyc.type gstype_checker_gstyc_type
$gsdeclare type-checker.gsrun.type gstype_checker_gsrun_type
$gsdeclare type-checker.args.type gstype_checker_args_type

gstype_checker_global_env = [gs:value|
    type-checker.env.type.insert (gsvar qq{gsmain}) (
        type.function type-checker.gstyc.type $
            type.function type-checker.gsrun.type $
                type.app (type.const (gsvar qq{gsi.m})) type.empty-signature
    ) $
    type-checker.env.type.insert (gsvar qq{undefined}) (
        type.forall (gsvar qq{α}) kind.pointed $
            type.function (type.const (gsvar qq{stack-trace.t})) $ type.const (gsvar qq{α})
    ) $
    type-checker.env.implicits.insert (gsvar qq{undefined}) (implicit.here : nil) $
    type-checker.env.empty
|]

gstype_checker_gstyc_type = [gs:value|
    type.function (type.const (gsvar qq{pos.t})) $
        type.function (type.const (gsvar qq{type.t})) $
            type.app (type.const (gsvar qq{type-checker.m})) type.empty-signature
|]

gstype_checker_gsrun_type = [gs:value|
    type.function (type.const (gsvar qq{gsvalue.t})) $
        type.function type-checker.args.type $
            type.app (type.const (gsvar qq{gsi.m})) type.empty-signature
|]

gstype_checker_args_type = [gs:value|
    type.app (type.const (gsvar qq{list.t})) $ type.app (type.const (gsvar qq{list.t})) $ type.const (gsvar qq{rune.t})
|]

gscompiler_global_env = [gs:value|
    ordered-map.insert gsvar.compare (gsvar qq{gsmain}) (gsinject gsmain) $
    ordered-map.insert gsvar.compare (gsvar qq{undefined}) (gsinject (value undefined)) $
    ordered-map.empty
|]
