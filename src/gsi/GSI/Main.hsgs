{-# LANGUAGE TemplateHaskell #-}
module GSI.Main (gsmain, gstype_checker_unify, gstype_checker_for, gstype_checker_unit, gstype_checker_env_empty) where

$gsimports

$gsdeclare gsprocessargs gsprocessargs

-- Main function (call this to start your interpreter)
gsmain = [gs:value| λ 'gstyc. λ 'gsrun. impfor 'args ← env.get-args;. gsprocessargs args gstyc gsrun |]

$gsdeclare file file
$gsdeclare process-document gsprocessDocument

-- Loops over arguments to process them
gsprocessargs = [gs:value| λ 'args. λ 'gstyc. λ 'gsrun. analyze args.
    case 'a : 'as. analyze-impM file.stat a.
        case left 'e. (analyze e.
            case ENOENT 'fn.
                impfor
                    _ ← print-error qq{§(a): Could not load: no such file or directory\n};
                  . error log{Process §(gsv a) (§(gsv e)) next}
        )
        case right 'st. (analyze st #is.dir.
            case true. gsprocessargs as gstyc gsrun -- Ignore all arguments until we start failing tests for it
            case false. impfor 's ← file.read a;. (analyze parse advance-rune print-rune file 〈 'filename ∝ a; 'line ∝ 1; 'col ∝ 1; 〉 s.
                case left 'err. impfor
                    _ ← print-error qq{§(err)\n};
                  . error log{§(gsv a): process §(gsv err) next}
                case right 'd. (analyze d.
                    case file.document 'pos 'mb. (analyze process-document pos gstyc mb.
                        case left 'err. impfor
                                _ ← print-error qq{§(err)\n};
                            . error log{Errors next}
                        case right 'prog. impfor 'progv ← gsthunk pos prog;. gsrun progv as
                    )
                )
            )
        )
|]

$gsdeclare pragmas pragmas;
$gsdeclare expr expr;

file = [gs:value|
    <|> parser-for
            _ ← pragmas;
            'pos ← get-pos;
            'mb ← optional expr;
        . parser.unit (file.document pos mb)
|]

pragmas = [gs:value hsvs=pragmawhitespace,| pragmawhitespace *> many empty |]

pragmawhitespace = [gs:value| many (
    <|> (
        *> string qq{#!}
        *> many (matching log{comment body character} (λ 'c. c ≠ r{\n}))
        *> char r{\n}
        *> parser.unit 〈〉
    )
    <|> (
        *> string qq{\n}
        *> parser.unit 〈〉
    )
) |]

$gsdeclare expr.atom gsexpr_atom

expr = [gs:value|
    <|> parser.unit (foldl expr.app) <*> expr.atom <*> many (parser.unit arg.expr <*> get-pos <*> expr.atom)
|]

$gsdeclare ident ident

gsexpr_atom = [gs:value|
    <|> parser.map expr.var ident
|]

$gsdeclare lexeme lexeme

$gsdeclare ident-start-char identStartChar
$gsdeclare ident-cont-char identContChar

ident = [gs:value| parser.map gsvar (
    lexeme (parser.map2 (:) ident-start-char (many ident-cont-char) <* not-followed-by ident-cont-char)
)|]

identStartChar = [gs:value| matching log{ident start character} is-lower |]
identContChar = [gs:value| matching log{ident cont character} is-lower |]

$gsdeclare whitespace whitespace

lexeme = [gs:value| λ 'p. p <* whitespace |]

whitespace = [gs:value| many (matching log{whitespace} is-space) |]

$gsdeclare type-checker.run gstype_checker_run

$gsdeclare type-checker.global-env gstype_checker_global_env

$gsdeclare compiler.global-env gscompiler_global_env

$gsdeclare type-check.document gstype_check_document

gsprocessDocument = [gs:value| λ 'pos. λ 'gstyc. λ 'mbe.
    either.for
        'mbe1 ← type-checker.run (type-check.document pos gstyc mbe) type-checker.global-env;
    . right (compile-document pos compiler.global-env mbe1)
|]

$gsdeclare type-checker.new-unifiable-var gs_type_checker_new_unifiable_var
$gsdeclare type-check-expr gstype_check_expr

gstype_check_document = [gs:value| λ 'pos. λ 'gstyc. λ 'mbe. type-checker.for
        'ty ← type-checker.new-unifiable-var;
        'mbe1 ← analyze mbe.
            case nothing. type-checker.unit nothing
            case just 'e. type-checker.for 'e1 ← type-check-expr pos e ty;. type-checker.unit (just e1)
        ;
        _ ← gstyc pos ty;
    . type-checker.unit mbe1
|]

$gsdeclare type-check-implicit gstype_check_implicit
$gsdeclare type-check-arg gstype_check_arg

$gsdeclare get-type gstype_checker_get_type
$gsdeclare get-implicit gstype_checker_get_implicit
$gsdeclare instantiate gstype_checker_instantiate

gstype_check_expr = [gs:value| λ 'pos. λ 'e. λ 'tye. analyze e.
    case expr.var 'v. type-checker.for
            'tya ← get-type pos v;
            'tyai ← instantiate tya;
            'ims ← get-implicit v;
            'imtys ← type-checker.mapM (λ _. type-checker.new-unifiable-var) ims;
            _ ← type-checker.unify pos tyai (foldr type.function tye imtys);
            'imas ← type-checker.zip-withM (type-check-implicit pos) ims imtys;
        . type-checker.unit (foldl expr.app (expr.var v) imas)
    case expr.app 'ef 'ex. type-checker.for
            'tyx ← type-checker.new-unifiable-var;
            'ef1 ← type-check-expr pos ef (type.function tyx tye);
            'ex1 ← type-check-arg pos ex tyx;
        . type-checker.unit (expr.app ef1 ex1)
|]

gstype_check_implicit = [gs:value| λ 'pos. λ 'im. λ 'ty. analyze im.
    case implicit.here. type-checker.for
            _ ← type-checker.unify pos (type.const (gsvar qq{stack-trace.t})) ty;
        . type-checker.unit arg.here
|]

gstype_check_arg = [gs:value| λ 'pos. λ 'a. λ 'ty. analyze a.
    case arg.expr 'pos1 'e. type-checker.map (arg.expr pos1) (type-check-expr pos1 e ty)
|]

$gsdeclare type-checker.incorrect-type gstype_checker_incorrect_type

$gsdeclare type-checker.unify-var gstype_checker_unify_var
$gsdeclare type-checker.unify-do-var gstype_checker_unify_do_var

gstype_checker_unify = [gs:value| λ 'pos. λ 'ty0. λ 'ty1. analyze ty0.
    case type.unifiable-var 'v0. (analyze-type-checker-M type-checker.get-var v0.
        case nothing. (analyze ty1.
            case type.app _ _. type-checker.unify-var v0 ty1
            case type.unifiable-var 'v1. (analyze st.ref.≡ v0 v1.
                case false. type-checker.unify-var v0 ty1
            )
            case type.function _ _. type-checker.unify-var v0 ty1
        )
        case just 'ty01. type-checker.unify pos ty01 ty1
    )
    case type.empty-signature. (analyze ty1.
        case type.empty-signature. type-checker.unit 〈〉
    )
    case type.app 'ty00 'ty01. (analyze ty1.
        case type.unifiable-var 'v1. type-checker.unify-do-var pos ty0 v1
        case type.app 'ty10 'ty11. type-checker.for
                _ ← type-checker.unify pos ty00 ty10;
                _ ← type-checker.unify pos ty01 ty11;
            . type-checker.unit 〈〉
    )
    case type.function 'ty00 'ty01. (analyze ty1.
        case type.app _ _. type-checker.incorrect-type pos ty0 ty1
        case type.function 'ty10 'ty11. type-checker.for
                _ ← type-checker.unify pos ty00 ty10;
                _ ← type-checker.unify pos ty01 ty11;
            . type-checker.unit 〈〉
        case type.unifiable-var 'v1. type-checker.unify-do-var pos ty0 v1
    )
    case type.const 'c0. (analyze ty1.
        case type.unifiable-var 'v1. type-checker.unify-do-var pos ty0 v1
        case type.const 'c1. (analyze gsvar.compare c0 c1.
            case eq. type-checker.unit 〈〉
        )
        case type.function _ _. type-checker.incorrect-type pos ty0 ty1
    )
|]

gstype_checker_unify_do_var = [gs:value| λ 'pos. λ 'ty. λ 'v. analyze-type-checker-M type-checker.get-var v.
    case nothing. type-checker.unify-var v ty
    case just 'ty1. type-checker.unify pos ty ty1
|]

$gsdeclare type-checker.is-free-in gstype_checker_is_free_in

gstype_checker_unify_var = [gs:value| λ 'v. λ 'ty. analyze-type-checker-M type-checker.is-free-in v ty.
    case false. type-checker.set-var (just ty) v
|]

gstype_checker_is_free_in = [gs:value| λ 'v. λ 'ty. analyze ty.
    case type.unifiable-var 'v1. (analyze st.ref.≡ v v1.
        case false. (analyze-type-checker-M type-checker.get-var v1.
            case nothing. type-checker.unit false
            case just 'ty1. type-checker.is-free-in v ty1
        )
    )
    case type.app 'ty0 'ty1. (analyze-type-checker-M type-checker.is-free-in v ty0.
        case false. type-checker.is-free-in v ty1
    )
    case type.const 'c. type-checker.unit false
    case type.empty-signature. type-checker.unit false
    case type.function 'ty0 'ty1. (analyze-type-checker-M type-checker.is-free-in v ty0.
        case false. type-checker.is-free-in v ty1
    )
|]

gstype_checker_run = [gs:value| λ 'a. λ 'env. st.run (a env) |]

gstype_checker_for = [gs:value| λ 'gens. λ 'a. type-checker.>>= gens a |]

gstype_checker_unit = [gs:value| λ 'x. λ 'env. impunit (right x) |]

gstype_checker_map = [gs:value| λ 'f. λ 'a. λ 'env. analyze-impM a env.
    case left 'err. impunit (left err)
    case right 'x. impunit (right (f x))
|]

gstype_checker_bind = [gs:value| λ 'a. λ 'k. λ 'env. analyze-impM a env.
    case left 'err. impunit (left err)
    case right 'x. k x env
|]

gstype_checker_analyze = [gs:value| λ 'e. λ 'c. type-checker.>>= e c |]

gstype_checker_mapM = [gs:value| λ 'f. λ 'xn. analyze xn.
    case nil. type-checker.unit nil
    case 'x:'xn1. type-checker.for 'y ← f x; 'ys1 ← type-checker.mapM f xn1;. type-checker.unit (y : ys1)
|]

gstype_checker_zipWithM = [gs:value| λ 'f. λ 'xn. λ 'ys. analyze xn. -- FIXME: Not parallel!
    case nil. type-checker.unit nil
    case 'x:'xn1. analyze ys.
        case 'y:'ys1. type-checker.for
                'z ← f x y;
                'zs1 ← type-checker.zip-withM f xn1 ys1;
            . type-checker.unit (z : zs1)
|]

gstype_checker_get_var = [gs:value| λ 'v. λ 'env. impfor 'mb ← st.get-var v;. impunit (right mb) |]
gstype_checker_set_var = [gs:value| λ 'x. λ 'v. λ 'env. impfor _ ← st.set-var x v;. impunit (right 〈〉) |]

$gsdeclare type-checker.fmt-type gstype_checker_fmt_type

gstype_checker_incorrect_type = [gs:value| λ 'pos. λ 'ty0. λ 'ty1. type-checker.for
        's0 ← type-checker.fmt-type ty0;
        's1 ← type-checker.fmt-type ty1;
    . λ 'env. impunit (left (pos.fmt pos qq{Incorrect type: §(s0) is not §(s1)}))
|]

gstype_checker_fmt_type = [gs:value| λ 'ty. analyze ty.
    case type.unifiable-var 'v. (analyze-type-checker-M type-checker.get-var v.
        case nothing. type-checker.unit qq{_}
    )
    case type.const 'c. type-checker.unit (gsvar.fmt-atom c)
    case type.app 'ty0 'ty1. type-checker.for
            's0 ← type-checker.fmt-type ty0;
            's1 ← type-checker.fmt-type ty1;
        . type-checker.unit qq{§(s0) §(s1)}
    case type.function 'ty0 'ty1. type-checker.for
            's0 ← type-checker.fmt-type ty0;
            's1 ← type-checker.fmt-type ty1;
        . type-checker.unit qq{§(s0) → §(s1)}
    case type.empty-signature. type-checker.unit qq{〈〉}
|]

$gsdeclare type-checker.env.type.insert gstype_checker_env_type_insert

$gsdeclare type-checker.gstyc.type gstype_checker_gstyc_type
$gsdeclare type-checker.gsrun.type gstype_checker_gsrun_type
$gsdeclare type-checker.args.type gstype_checker_args_type

gstype_checker_global_env = [gs:value|
    type-checker.env.type.insert (gsvar qq{gsmain}) (
        type.function type-checker.gstyc.type $
            type.function type-checker.gsrun.type $
                type.app (type.const (gsvar qq{gsi.m})) type.empty-signature
    ) $
    type-checker.env.type.insert (gsvar qq{undefined}) (
        type.forall (gsvar qq{α}) kind.pointed $
            type.function (type.const (gsvar qq{stack-trace.t})) $ type.const (gsvar qq{α})
    ) $
    type-checker.env.implicits.insert (gsvar qq{undefined}) (implicit.here : nil) $
    type-checker.env.empty
|]

gstype_checker_gstyc_type = [gs:value|
    type.function (type.const (gsvar qq{pos.t})) $
        type.function (type.const (gsvar qq{type.t})) $
            type.app (type.const (gsvar qq{type-checker.m})) type.empty-signature
|]

gstype_checker_gsrun_type = [gs:value|
    type.function (type.const (gsvar qq{gsvalue.t})) $
        type.function type-checker.args.type $
            type.app (type.const (gsvar qq{gsi.m})) type.empty-signature
|]

gstype_checker_args_type = [gs:value|
    type.app (type.const (gsvar qq{list.t})) $ type.app (type.const (gsvar qq{list.t})) $ type.const (gsvar qq{rune.t})
|]

gstype_checker_env_type_insert = [gs:value| λ 'v. λ 'ty. λ 'env. 〈
    'types ∝ ordered-map.insert gsvar.compare v ty (env #types);
    'implicits ∝ env #implicits;
〉 |]

gstype_checker_env_implicits_insert = [gs:value| λ 'v. λ 'is. λ 'env. 〈
    'types ∝ env #types;
    'implicits ∝ ordered-map.insert gsvar.compare v is (env #implicits);
〉 |]

gstype_checker_env_empty = [gs:value| 〈 'types ∝ ordered-map.empty; 'implicits ∝ ordered-map.empty; 〉 |]

gstype_checker_get_type = [gs:value| λ 'pos. λ 'v. λ 'env. analyze ordered-map.get gsvar.compare v (env #types).
    case nothing. impunit (left (pos.fmt pos qq{§(gsvar.fmt-atom v) not in scope}))
    case just 'ty. impunit (right ty)
|]

gstype_checker_get_implicit = [gs:value| λ 'v. λ 'env.
    impunit (right (analyze ordered-map.get gsvar.compare v (env #implicits).
        case nothing. nil
        case just 'is. is
    ))
|]

gstype_checker_instantiate = [gs:value| λ 'ty. analyze ty.
    case type.function 'ty0 'ty1. type-checker.unit ty
    case type.forall 'v 'ki 'ty1. type-checker.for 'v1 ← type-checker.new-unifiable-var;.
        type-checker.unit (type.subst v v1 ty1)
|]

gs_type_checker_new_unifiable_var = [gs:value| λ 'env. impfor 'v ← st.ref.new nothing;. impunit (right (type.unifiable-var v)) |]

gscompiler_global_env = [gs:value|
    ordered-map.insert gsvar.compare (gsvar qq{gsmain}) (gsinject gsmain) $
    ordered-map.insert gsvar.compare (gsvar qq{undefined}) (gsinject (value undefined)) $
    ordered-map.empty
|]
