{-# LANGUAGE TemplateHaskell #-}
module GSI.Main (gsmain) where

import GSI.Syn (gsvar)
import GSI.Value (gslambda, gsundefined_value, gsav)
import GSI.ByteCode (gsbcarg, gsbcrecord, gsbcundefined)
$gsimports

-- Main function (call this to start your interpreter)
gsmain = $gslambda $ \ gsrun -> [gs:expr hsvs=gsprocessargs,| impfor
        'args ← env.get-args;
    . gsprocessargs args
|]

-- Loops over arguments to process them
gsprocessargs = $gslambda $ \ args -> [gs:expr hsvs=gsprocessargs,args,parse,file,gspos,| analyze args.
    case 'a : 'as. analyze-impM file.stat a.
        case left 'e. (analyze e.
            case ENOENT 'fn.
                impfor
                    _ ← print-error qq{§(a): Could not load: no such file or directory\n};
                  . error log{Process §(gsv a) (§(gsv e)) next}
        )
        case right 'st. (analyze st #is.dir.
            case true. gsprocessargs as -- Ignore all arguments until we start failing tests for it
            case false. impfor 's ← file.read a;. (analyze parse file (gspos a 1 1) s.
                case left 'err. impfor
                    _ ← print-error qq{§(err)\n};
                  . error log{§(gsv a): process §(gsv err) next}
                case right 'd. error log{§(gsv a): process §(gsv d) next}
            )
        )
|]

parse = $gslambda $ \ p -> $gsbcarg $ \ pos -> $gsbcarg $ \ s -> [gs:expr hsvs=p,pos,s,| analyze p.
    case empty. left (pos.fmt pos qq{empty})
|]

file = [gs:value| <|> empty |]

gspos = $gslambda $ \ fn -> $gsbcarg $ \ l -> $gsbcarg $ \ c -> $gsbcrecord [
    (gsvar "filename", $gsav fn),
    (gsvar "line", $gsav l),
    (gsvar "col", $gsav c)
  ]
