{-# LANGUAGE TemplateHaskell #-}
module GSI.Main (gsmain, gstype_checker_for, gstype_checker_unit) where

import GSI.Syn (gsvar)
import GSI.Value (gslambda_value, gsconstr, gsundefined_value, gsav)
import GSI.ByteCode (gsbcarg, gsbcrecord, gsbcconstr, gsbcundefined, gsbcconstr_view)
$gsimports

-- Main function (call this to start your interpreter)
gsmain = $gslambda_value $ \ gstyc -> $gsbcarg $ \ gsrun -> [gs:expr hsvs=gsprocessargs,gstyc,gsrun,| impfor
        'args ← env.get-args;
    . gsprocessargs args gstyc gsrun
|]

$gsdeclare process-document gsprocessDocument

-- Loops over arguments to process them
gsprocessargs = $gslambda_value $ \ args -> $gsbcarg $ \ gstyc -> $gsbcarg $ \ gsrun -> [gs:expr hsvs=gsprocessargs,gstyc,gsrun,args,file,gspos,| analyze args.
    case 'a : 'as. analyze-impM file.stat a.
        case left 'e. (analyze e.
            case ENOENT 'fn.
                impfor
                    _ ← print-error qq{§(a): Could not load: no such file or directory\n};
                  . error log{Process §(gsv a) (§(gsv e)) next}
        )
        case right 'st. (analyze st #is.dir.
            case true. gsprocessargs as gstyc gsrun -- Ignore all arguments until we start failing tests for it
            case false. impfor 's ← file.read a;. (analyze parse advance-rune file (gspos a 1 1) s.
                case left 'err. impfor
                    _ ← print-error qq{§(err)\n};
                  . error log{§(gsv a): process §(gsv err) next}
                case right 'd. (analyze d.
                    case file.document 'pos 'mb. (analyze process-document pos gstyc mb.
                        case left 'err. impfor
                                _ ← print-error qq{§(err)\n};
                            . error log{Errors next}
                        case right 'prog. gsrun prog as
                    )
                )
            )
        )
|]

$gsdeclare pragmas pragmas;
$gsdeclare expr expr;

file = [gs:value|
    <|> parser-for
            _ ← pragmas;
            'pos ← get-pos;
            'mb ← optional expr;
        . parser.unit (file.document pos mb)
|]

pragmas = [gs:value hsvs=pragmawhitespace,| pragmawhitespace *> many empty |]

pragmawhitespace = [gs:value| many (
    <|> (
        *> string qq{#!}
        *> many (matching log{comment body character} (λ 'c. c ≠ r{\n}))
        *> char r{\n}
        *> parser.unit 〈〉
    )
    <|> (
        *> string qq{\n}
        *> parser.unit 〈〉
    )
) |]

$gsdeclare expr.var gsexpr_var

$gsdeclare ident ident

expr = [gs:value|
    <|> parser.map expr.var ident
|]

$gsdeclare lexeme lexeme

$gsdeclare ident-start-char identStartChar
$gsdeclare ident-cont-char identContChar

ident = [gs:value| parser.map gsvar (
    lexeme (parser.map2 (:) ident-start-char (many ident-cont-char) <* not-followed-by ident-cont-char)
)|]

identStartChar = [gs:value| matching log{ident start character} is-lower |]
identContChar = [gs:value| matching log{ident cont character} is-lower |]

$gsdeclare whitespace whitespace

lexeme = [gs:value| λ 'p. p <* whitespace |]

whitespace = [gs:value| many (matching log{whitespace} is-space) |]

$gsdeclare type-checker.run gstype_checker_run
$gsdeclare type-checker.env.empty gstype_checker_env_empty

$gsdeclare type-checker.global-env gstype_checker_global_env

$gsdeclare type-check-document gstypeCheckDocument
$gsdeclare compile-document gscompileDocument

gsprocessDocument = [gs:value| λ 'pos. λ 'gstyc. λ 'mbe.
    either-for
        _ ← type-checker.run (type-check-document pos gstyc mbe) type-checker.global-env;
        'p ← compile-document pos mbe;
    . right p
|]

$gsdeclare type-check-expr gstype_check_expr

gstypeCheckDocument = [gs:value| λ 'pos. λ 'gstyc. λ 'mbe. type-checker.for
        _ ← maybe (type-checker.unit undefined) (type-check-expr pos) mbe;
        _ ← gstyc undefined;
    . type-checker.unit undefined
|]

$gsdeclare view expr.var gsexpr_var_view

$gsdeclare get-type gstype_checker_get_type

gstype_check_expr = [gs:value| λ 'pos. λ 'e. analyze e.
    case expr.var 'v. get-type pos v
|]

gstype_checker_run = [gs:value| λ 'a. λ 'env. st.run (a env) |]

gstype_checker_for = [gs:value| λ 'gens. λ 'a. type-checker.>>= gens a |]

gstype_checker_unit = [gs:value| λ 'x. λ 'env. impunit (right x) |]

gstype_checker_map = [gs:value| λ 'f. λ 'a. λ 'env. analyze-impM a env.
    case left 'err. impunit (left err)
    case right 'x. impunit (right (f x))
|]

gstype_checker_bind = [gs:value| λ 'a. λ 'k. λ 'env. analyze-impM a env.
    case left 'err. impunit (left err)
    case right 'x. k x env
|]

gstype_checker_analyze = [gs:value| λ 'e. λ 'c. type-checker.>>= e c |]

$gsdeclare type-checker.env.type.insert gstype_checker_env_type_insert

gstype_checker_global_env = [gs:value|
    type-checker.env.type.insert (gsvar qq{gsmain}) undefined $
    type-checker.env.empty
|]

gstype_checker_env_type_insert = [gs:value| λ 'v. λ 'ty. λ 'env. 〈
    'types ∝ ordered-map.insert gsvar.compare v ty (env #types);
〉 |]

gstype_checker_env_empty = [gs:value| 〈 'types ∝ ordered-map.empty; 〉 |]

gstype_checker_get_type = [gs:value| λ 'pos. λ 'v. λ 'env. analyze ordered-map.get gsvar.compare v (env #types).
    case nothing. impunit (left (pos.fmt pos qq{§(gsvar.fmt-atom v) not in scope}))
    case just 'ty. impunit (right ty)
|]

$gsdeclare compile-expr gscompileExpr

gscompileDocument = [gs:value| λ 'pos. λ 'mbe. analyze mbe.
    case nothing. right (gsundefined pos)
    case just 'e. compile-expr pos undefined e
|]

gscompileExpr = [gs:value| λ 'pos. λ 'env. λ 'e. analyze e.
    case expr.var 'v. (analyze ordered-map.get gsvar.compare v env.
    )
|]

gsfileDocument = $gslambda_value $ \ pos -> $gsbcarg $ \ mb -> $gsbcconstr (gsvar "document") [ $gsav pos, $gsav mb ]

gsfileDocument_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "document" ek sk e

gsexpr_var = $gslambda_value $ \ id -> $gsbcconstr (gsvar "var") [ $gsav id ]

gsexpr_var_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "var" ek sk e

gspos = $gslambda_value $ \ fn -> $gsbcarg $ \ l -> $gsbcarg $ \ c -> $gsbcrecord [
    (gsvar "filename", $gsav fn),
    (gsvar "line", $gsav l),
    (gsvar "col", $gsav c)
  ]
