{-# LANGUAGE TemplateHaskell #-}
module GSI.Main (gsmain) where

import GSI.Syn (gsvar)
import GSI.Value (gslambda, gsconstr, gsundefined_value, gsav)
import GSI.ByteCode (gsbcarg, gsbcrecord, gsbcundefined, gsbcconstr_view)
$gsimports

-- Main function (call this to start your interpreter)
gsmain = $gslambda $ \ gstyc -> $gsbcarg $ \ gsrun -> [gs:expr hsvs=gsprocessargs,gstyc,gsrun,| impfor
        'args ← env.get-args;
    . gsprocessargs args gstyc gsrun
|]

-- Loops over arguments to process them
gsprocessargs = $gslambda $ \ args -> $gsbcarg $ \ gstyc -> $gsbcarg $ \ gsrun -> [gs:expr hsvs=gsprocessargs,gstyc,gsrun,args,file,gspos,| analyze args.
    case 'a : 'as. analyze-impM file.stat a.
        case left 'e. (analyze e.
            case ENOENT 'fn.
                impfor
                    _ ← print-error qq{§(a): Could not load: no such file or directory\n};
                  . error log{Process §(gsv a) (§(gsv e)) next}
        )
        case right 'st. (analyze st #is.dir.
            case true. gsprocessargs as gstyc gsrun -- Ignore all arguments until we start failing tests for it
            case false. impfor 's ← file.read a;. (analyze parse file (gspos a 1 1) s.
                case left 'err. impfor
                    _ ← print-error qq{§(err)\n};
                  . error log{§(gsv a): process §(gsv err) next}
                case right 'd. (analyze d.
                    case file.document. (analyze process-document (gspos a 1 1) gstyc.
                        case right 'prog. gsrun prog as
                    )
                )
            )
        )
|]

file = [gs:value| <|> parser.unit file.document |]

gsprocessDocument = $gslambda $ \ pos -> $gsbcarg $ \ gstyc -> [gs:expr hsvs=pos,gstyc,|
    either-for
        _ ← type-check-document pos gstyc;
        'p ← compile-document pos;
    . right p
|]

gstypeCheckDocument = $gslambda $ \ pos -> $gsbcarg $ \ gstyc -> [gs:expr| right undefined |]

gscompileDocument = $gslambda $ \ pos -> [gs:expr hsvs=pos,| right (gsundefined pos) |]

gsfileDocument = $gsconstr (gsvar "document") []

gsfileDocument_view = $gslambda $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "document" ek sk e

gspos = $gslambda $ \ fn -> $gsbcarg $ \ l -> $gsbcarg $ \ c -> $gsbcrecord [
    (gsvar "filename", $gsav fn),
    (gsvar "line", $gsav l),
    (gsvar "col", $gsav c)
  ]
