{-# LANGUAGE TemplateHaskell #-}
module GSI.Main (gsmain) where

$gsimports

$gsdeclare gsprocessargs gsprocessargs

-- Main function (call this to start your interpreter)
gsmain = [gs:value| λ 'gstyc. λ 'gsrun. impfor 'args ← env.get-args;. gsprocessargs args gstyc gsrun |]

$gsdeclare parser.global-env gsparser_global_env
$gsdeclare process-document gsprocess_document

-- Loops over arguments to process them
gsprocessargs = [gs:value| λ 'args. λ 'gstyc. λ 'gsrun. analyze args.
    case 'a : 'as. analyze-impM file.stat a.
        case left 'e. (analyze e.
            case ENOENT 'fn.
                impfor
                    _ ← print-error qq{§(a): Could not load: no such file or directory\n};
                  . error log{Process §(gsv a) (§(gsv e)) next}
        )
        case right 'st. (analyze st #is.dir.
            case true. gsprocessargs as gstyc gsrun -- Ignore all arguments until we start failing tests for it
            case false. impfor 's ← file.read a;. (analyze parse advance-rune print-rune (file parser.global-env) 〈 'filename ∝ a; 'line ∝ 1; 'col ∝ 1; 〉 s.
                case left 'err. impfor
                    _ ← print-error qq{§(err)\n};
                  . error log{§(gsv a): process §(gsv err) next}
                case right 'd. (analyze d.
                    case file.document 'pos 'd. (analyze process-document pos gstyc d.
                        case left 'err. impfor
                                _ ← print-error qq{§(err)\n};
                            . error log{Errors next}
                        case right 'prog. impfor 'progv ← gsthunk pos prog;. gsrun progv as
                    )
                )
            )
        )
|]

$gsdeclare annotator.global-env gsannotator_global_env
$gsdeclare validator.global-env gsvalidator_global_env
$gsdeclare type-checker.global-env gstype_checker_global_env
$gsdeclare compiler.global-env gscompiler_global_env

gsprocess_document = [gs:value| λ 'pos. λ 'gstyc. λ 'd.
    either.for
            'dspec ← right (annotate-document annotator.global-env pos d);
            _ ← validate-document pos validator.global-env dspec;
            'dty ← type-checker.run (type-check-document pos gstyc dspec) type-checker.global-env;
        . right (compile-document pos compiler.global-env dty)
|]

gsparser_global_env = [gs:value|
    parser.env.syntactic-category.insert (gsvar qq{analyze}) syntactic-category.lambda-like $
    parser.env.missing-body.insert (gsvar qq{analyze}) expr.missing-case $
    parser.env.syntactic-category.insert (gsvar qq{case}) syntactic-category.lambda-like $
    parser.env.else.insert (gsvar qq{case}) 〈〉 $
    parser.env.missing-else.insert (gsvar qq{case}) expr.missing-case $
    parser.env.signature.insert (gsvar qq{case}) (order-of-being.pattern : order-of-being.open-expr : nil) $
    parser.env.syntactic-category.insert (gsvar qq{where}) syntactic-category.where $
    parser.env.syntactic-category.insert (gsvar qq{λ}) syntactic-category.lambda-like $
    parser.env.signature.insert (gsvar qq{λ}) (order-of-being.pattern : order-of-being.open-expr : nil) $
    parser.env.op.insert (gsvar qq{∘}) 〈〉 $
    parser.env.empty
|]

gsannotator_global_env = [gs:value|
    annotator.env.namespace.insert (gsvar qq{λ}) (λ 'as. analyze as.
        case (arg.expr _ (expr.pat 'p0 _)):((arg.expr _ (expr.open-expr 'e1 _)):_). just (pat.bound-vars p0) : just (pat.bound-vars p0) : nil
    ) $
    annotator.env.namespace.insert (gsvar qq{case}) (λ 'as. analyze as.
        case (arg.expr _ (expr.pat 'p0 _)):((arg.expr _ (expr.open-expr 'e1 _)):_). just (pat.bound-vars p0) : just (pat.bound-vars p0) : nil
    ) $
    annotator.env.category.insert (gsvar qq{case}) (λ 'as. analyze as.
        case (arg.expr _ (expr.pat 'p0 _)):_. just category.monoidal : nil
    ) $
    annotator.env.empty
|]

gsvalidator_global_env = [gs:value|
    validator.env.in-scope.insert (gsvar qq{analyze}) $
    validator.env.in-scope.insert (gsvar qq{case}) $
    validator.env.in-scope.insert (gsvar qq{gsmain}) $
    validator.env.in-scope.insert (gsvar qq{type-checker.unit}) $
    validator.env.in-scope.insert (gsvar qq{undefined}) $
    validator.env.in-scope.insert (gsvar qq{λ}) $
    validator.env.empty
|]

$gsdeclare type.consts gstype_consts

$gsdeclare type.pattern gstype_pattern
$gsdeclare type.pattern.monoidal gstype_pattern_monoidal
$gsdeclare type.generator gstype_generator
$gsdeclare type.generator.monoidal gstype_generator_monoidal
$gsdeclare type.open-expr gstype_open_expr

$gsdeclare type-checker.gstyc.type gstype_checker_gstyc_type
$gsdeclare type-checker.gsrun.type gstype_checker_gsrun_type
$gsdeclare type-checker.args.type gstype_checker_args_type

gstype_checker_global_env = [gs:value|
    type.env.type.insert (gsvar qq{analyze}) (
        type.forall (gsvar qq{α}) kind.pointed $ type.forall (gsvar qq{β}) kind.pointed $
            type.function (type.consts qq{α}) $
                type.function (type.function (type.consts qq{α}) (type.consts qq{β})) $
                    type.consts qq{β}
    ) $
    type.env.type.insert (gsvar qq{case}) (
        type.forall (gsvar qq{α}) kind.pointed $ type.forall (gsvar qq{σ}) kind.pointed $ type.forall (gsvar qq{β}) kind.pointed $
            type.function (type.pattern.monoidal (type.consts qq{α}) (type.consts qq{σ})) $
                type.function (type.open-expr (type.consts qq{σ}) (type.consts qq{β})) $
                    type.function (type.function (type.consts qq{α}) (type.consts qq{β})) $
                        type.function (type.consts qq{α}) (type.consts qq{β})
    ) $
    type.env.type.insert (gsvar qq{λ}) (
        type.forall (gsvar qq{α}) kind.pointed $ type.forall (gsvar qq{β}) kind.pointed $ type.forall (gsvar qq{σ}) kind.pointed $
            type.function (type.pattern (type.consts qq{α}) (type.consts qq{σ})) $
                type.function (type.open-expr (type.consts qq{σ}) (type.consts qq{β})) $
                    type.function (type.consts qq{α}) (type.consts qq{β})
    ) $
    type.env.type.insert (gsvar qq{gsvar}) (
        type.function (type.app (type.consts qq{gsvar.t}) (type.consts qq{rune.t})) $ type.consts qq{gsvar.t}
    ) $
    type.env.type.insert (gsvar qq{gsmain}) (
        type.function type-checker.gstyc.type $
            type.function type-checker.gsrun.type $
                type.app (type.const (gsvar qq{gsi.m})) type.empty-signature
    ) $
    type.env.type.insert (gsvar qq{type.app}) (
        type.function (type.consts qq{type.t}) $ type.function (type.consts qq{type.t}) $ type.consts qq{type.t}
    ) $
    type.env.type.insert (gsvar qq{type.const}) (
        type.function (type.consts qq{gsvar.t}) $ type.consts qq{type.t}
    ) $
    type.env.type.insert (gsvar qq{type.empty-signature}) (type.consts qq{type.t}) $
    type.env.type.insert (gsvar qq{type-checker.unify}) (
        type.function (type.consts qq{pos.t}) $
            type.function (type.consts qq{type.t}) $ type.function (type.consts qq{type.t}) $
                type.app (type.const (gsvar qq{type-checker.m})) type.empty-signature
    ) $
    type.env.type.insert (gsvar qq{type-checker.unit}) (
        type.forall (gsvar qq{α}) kind.pointed $
            type.function (type.consts qq{α}) $ type.app (type.consts qq{type-checker.m}) (type.consts qq{α})
    ) $
    type.env.type.insert (gsvar qq{map}) (
        type.forall (gsvar qq{α}) kind.pointed $ type.forall (gsvar qq{β}) kind.pointed $
            type.function (type.function (type.consts qq{α}) (type.consts qq{β})) $
                type.function (type.app (type.consts qq{list.t}) (type.consts qq{α})) (type.app (type.consts qq{list.t}) (type.consts qq{β}))
    ) $
    type.env.type.insert (gsvar qq{true}) (type.consts qq{bool.t}) $
    type.env.view-type.insert (gsvar qq{true}) (type.consts qq{bool.t}) $
    type.env.view-type.insert (gsvar qq{false}) (type.consts qq{bool.t}) $
    type.env.type.insert (gsvar qq{just}) (
        type.forall (gsvar qq{α}) kind.pointed $ type.function (type.consts qq{α}) $
            type.app (type.consts qq{maybe.t}) (type.consts qq{α})
    ) $
    type.env.view-type.insert (gsvar qq{just}) (
        type.forall (gsvar qq{α}) kind.pointed $ type.function (type.consts qq{α}) $
            type.app (type.consts qq{maybe.t}) (type.consts qq{α})
    ) $
    type.env.view-type.insert (gsvar qq{nothing}) (
        type.forall (gsvar qq{α}) kind.pointed $ type.app (type.consts qq{maybe.t}) (type.consts qq{α})
    ) $
    type.env.type.insert (gsvar qq{undefined}) (
        type.forall (gsvar qq{α}) kind.pointed $
            type.function (type.const (gsvar qq{stack-trace.t})) $ type.const (gsvar qq{α})
    ) $
    type.env.implicits.insert (gsvar qq{undefined}) (implicit.here : nil) $
    type.env.type.insert (gsvar qq{∘}) (
        type.forall (gsvar qq{α}) kind.pointed $ type.forall (gsvar qq{β}) kind.pointed $ type.forall (gsvar qq{γ}) kind.pointed $
            type.function (type.function (type.consts qq{β}) (type.consts qq{γ})) $
                type.function (type.function (type.consts qq{α}) (type.consts qq{β})) $
                    type.function (type.consts qq{α}) (type.consts qq{γ})
    ) $
    type.env.view-type.insert (gsvar qq{gsvalue.thunk}) (
        type.function (type.consts qq{gsvalue.thunk.t}) $ type.consts qq{gsvalue.t}
    ) $
    type.env.empty
|]

gstype_checker_gstyc_type = [gs:value|
    type.function (type.const (gsvar qq{pos.t})) $
        type.function (type.const (gsvar qq{type.t})) $
            type.app (type.const (gsvar qq{type-checker.m})) type.empty-signature
|]

gstype_checker_gsrun_type = [gs:value|
    type.function (type.const (gsvar qq{gsvalue.t})) $
        type.function type-checker.args.type $
            type.app (type.const (gsvar qq{gsi.m})) type.empty-signature
|]

gstype_checker_args_type = [gs:value|
    type.app (type.const (gsvar qq{list.t})) $ type.app (type.const (gsvar qq{list.t})) $ type.const (gsvar qq{rune.t})
|]

gstype_pattern = [gs:value| λ 'α. λ 'σ. type.function α $ type.generator σ |]
gstype_pattern_monoidal = [gs:value| λ 'α. λ 'σ. type.function α $ type.generator.monoidal σ |]
gstype_generator = [gs:value| λ 'σ. σ |]
gstype_generator_monoidal = [gs:value| λ 'σ. type.app (type.consts qq{generator.monoidal.t}) σ |]
gstype_open_expr = [gs:value| λ 'σ. λ 'α. type.function σ α |]

gstype_consts = [gs:value| λ 's. type.const (gsvar s) |]

gscompiler_global_env = [gs:value|
    compiler.env.value.insert (gsvar qq{analyze}) (gsinject (value analyze)) $
    compiler.env.value.insert (gsvar qq{case}) (gsinject (value case)) $
    compiler.env.value.insert (gsvar qq{gsmain}) (gsinject gsmain) $
    compiler.env.value.insert (gsvar qq{gsvar}) (gsinject gsvar) $
    compiler.env.value.insert (gsvar qq{just}) (gsinject just) $
    compiler.env.value.insert (gsvar qq{map}) (gsinject map) $
    compiler.env.value.insert (gsvar qq{true}) (gsinject true) $
    compiler.env.value.insert (gsvar qq{type-checker.unify}) (gsinject type-checker.unify) $
    compiler.env.value.insert (gsvar qq{type-checker.unit}) (gsinject type-checker.unit) $
    compiler.env.value.insert (gsvar qq{type.app}) (gsinject type.app) $
    compiler.env.value.insert (gsvar qq{type.const}) (gsinject type.const) $
    compiler.env.value.insert (gsvar qq{type.empty-signature}) (gsinject type.empty-signature) $
    compiler.env.value.insert (gsvar qq{undefined}) (gsinject (value undefined)) $
    compiler.env.value.insert (gsvar qq{λ}) (gsinject (value λ)) $
    compiler.env.value.insert (gsvar qq{∘}) (gsinject (∘)) $
    compiler.env.view.insert (gsvar qq{false}) (gsinject (view false)) $
    compiler.env.view.insert (gsvar qq{gsvalue.thunk}) (gsinject (view gsvalue.thunk)) $
    compiler.env.view.insert (gsvar qq{just}) (gsinject (view just)) $
    compiler.env.view.insert (gsvar qq{nothing}) (gsinject (view nothing)) $
    compiler.env.view.insert (gsvar qq{true}) (gsinject (view true)) $
    compiler.env.empty
|]
