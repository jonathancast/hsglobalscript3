{-# LANGUAGE TemplateHaskell #-}
module GSI.Main (gsmain) where

import GSI.Value (gslambda, gsundefined)
import GSI.ByteCode (gsbcarg)
$gsimports

-- Main function (call this to start your interpreter)
gsmain = $gslambda $ \ gsrun -> [gs:expr hsvs=gsprocessargs,| impfor
        'args ← env.get-args;
    . gsprocessargs args
|]

-- Loops over arguments to process them
gsprocessargs = $gslambda $ \ args -> [gs:expr hsvs=gsprocessargs,args,parse,file,gspos,| analyze args.
    case 'a : 'as. analyze-impM file.stat a.
        case left 'e. (analyze e.
            case ENOENT 'fn.
                impfor
                    _ ← print-error qq{§(a): Could not load: no such file or directory\n};
                  . error log{Process §(gsv a) (§(gsv e)) next}
        )
        case right 'st. (analyze st #is.dir.
            case true. gsprocessargs as -- Ignore all arguments until we start failing tests for it
            case false. impfor 's ← file.read a;. (analyze parse file (gspos a 1 1) s.
                case left 'err. error log{§(gsv a): process §(gsv err) next}
                case right 'd. error log{§(gsv a): process §(gsv d) next}
            )
        )
|]

parse = $gslambda $ \ p -> $gsbcarg $ \ pos -> $gsbcarg $ \ s -> [gs:expr hsvs=p,s,| analyze p.
|]

file = [gs:value| empty |]

gspos = $gslambda $ \ fn -> [gs:expr hsvs=fn,| error log{gspos §(gsv fn) next} |]
