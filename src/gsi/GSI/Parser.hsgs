{-# LANGUAGE TemplateHaskell #-}
module GSI.Parser (gsparse, gsposFmt, gsparserFor, gsparser_app, gsparser_then, gsparser_unary_then, gsparser_after, gsparser_bind, gsparser_map, gsparser_unit, gsparser_map2, gsparser_matching, gsparser_string, gsparser_char, gsparser_optional, gsmany, gsparser_unary_or, gsparser_or, gsparser_getPos, gsempty, gsparser_notFollowedBy, gsparser_advanceRune, gsparser_print_rune) where

import GSI.Syn (gsvar)
import GSI.Value (GSValue, gslambda_value, gsconstr, gsundefined_value, gsav, gsae)
import GSI.ByteCode (gsbcarg, gsbcenter, gsbcapply, gsbcconstr, gsbcundefined, gsbcconstr_view)
import GSI.List (gsnil, gscons)
$gsimports

$gsdeclare prim.unit gsprimunit

$gsdeclare parse-process gsparse_process
$gsdeclare parse-w gsparsew

gsparse = [gs:value| λ 'adv. λ 'pr. λ 'p. λ 'pos. λ 's. for 'res ∝ parse-w adv pr (p prim.unit) pos s;. parse-process (res #0) (res #1) |]

$gsdeclare fmt-error gsfmtError

gsparse_process = [gs:value| λ 'xn. λ 'err. analyze xn.
    -- > case nil. left err
    case 'x0 : nil. (analyze x0 #1.
        case true. right (x0 #0)
        case false. left err
    )
    case 'x0 : 'xn1. parse-process xn1 err
|]

$gsdeclare prim.empty gsprim_empty

$gsdeclare view prim.empty gsprim_empty_view
$gsdeclare view prim.unit-plus gsprim_unit_plus_view
$gsdeclare view prim.get-pos gsprim_get_pos_view
$gsdeclare view prim.lookahead gsprim_lookahead_view
$gsdeclare view prim.symbol-or-eof gsprim_symbol_view

$gsdeclare process-lookahead gsparse_process_lookahead

gsparsew = [gs:value| λ 'adv. λ 'pr. λ 'p. λ 'pos. λ 's. analyze p.
    case prim.empty. 〈 '0 ∝ nil; '1 ∝ pos.fmt pos qq{Un-expected §(undefined); empty}; 〉
    case prim.unit-plus 'x 'p1. for 'r1 ∝ parse-w adv pr p1 pos s;. 〈
        '0 ∝ 〈 '0 ∝ x; '1 ∝ analyze s. case nil. true case _:_. false; 〉 : r1 #0;
        '1 ∝ r1 #1;
    〉
    case prim.get-pos 'k. parse-w adv pr (k pos) pos s
    case prim.lookahead 'pp. for 'res ∝ parse-w adv pr pp pos s;. parse-w adv pr (process-lookahead prim.empty (res #0) (res #1)) pos s
    case prim.symbol-or-eof 'ek 'sk. (analyze s.
        case nil. parse-w adv pr ek pos s
        case 'c:'s1. (analyze sk c.
            case left 'e. 〈 '0 ∝ nil; '1 ∝ pos.fmt pos qq{Un-expected §(pr c); §(fmt-error (e #0) (e #1))}; 〉
            case right 'p1. parse-w adv pr p1 (adv c pos) s1
        )
    )
|]

$gsdeclare prim.<|> gsprimor

gsparse_process_lookahead = [gs:value| λ 'p. λ 'xn. λ 'err. analyze xn.
    case 'x:'xn1. process-lookahead (prim.<|> p (x #0)) xn1 err
    case nil. prim.<|> p prim.empty
|]

gsposFmt :: GSValue
gsposFmt = $gslambda_value $ \ pos -> $gsbcarg $ \ msg ->
    [gs:expr hsvs=pos,msg,| qq{§(pos #filename):§(fmtdecimal (pos #line)):§(fmtdecimal (pos #col)): §(msg)} |]

gsfmtError = [gs:value| λ 'errs. λ 'exps. analyze errs.
    case nil. (analyze exps.
        case 'exp0:nil. qq{expected §(log.fmt exp0)}
    )
|]

gsparserFor = $gslambda_value $ \ gens -> $gsbcarg $ \ e -> $gsbcapply gsparser_bind [ $gsav gens, $gsav e ]

gsparser_bind = $gslambda_value $ \ p -> $gsbcarg $ \ f -> $gsbcarg $ \ k -> $gsbcapply p [ $gsae $ $gsbcarg $ \ x ->
    $gsbcapply f [ $gsav x, $gsav k ] ]

gsparser_app = [gs:value| λ 'pf. λ 'px. λ 'k. pf $ λ 'f. px $ λ 'x. k $ f $ undefined |]

gsparser_then = [gs:value| λ 'p0. λ 'p1. λ 'k. p0 (λ 'x0. p1 k) |]

gsparser_unary_then = [gs:value| λ 'p0. p0 |]

gsparser_after = [gs:value| λ 'p0. λ 'p1. λ 'k. p0 (λ 'x0. p1 (λ 'x1. k x0)) |]

gsparser_map = [gs:value| λ 'f. λ 'p. λ 'k. p (λ 'x. k (f x)) |]

gsparser_unit = $gslambda_value $ \ x -> $gsbcarg $ \ k -> $gsbcapply k [ $gsav x ]

gsparser_map2 = $gslambda_value $ \ f -> $gsbcarg $ \ p0 -> $gsbcarg $ \ p1 -> $gsbcarg $ \ k ->
    [gs:expr hsvs=f,p0,p1,k,| p0 (λ 'x0. p1 (λ 'x1. k (f x0 x1))) |]

gsparser_string = $gslambda_value $ \ s -> [gs:expr hsvs=s,| analyze s.
    case 'c:'s1. char c *> string s1
    case nil. parser.unit 〈〉
|]

gsparser_char = $gslambda_value $ \ ch -> [gs:expr hsvs=ch,| matching (display-rune ch) (rune.≡ ch) |]

$gsdeclare prim.symbol-or-eof gsprim_symbol

gsparser_matching = [gs:value| λ 'cat. λ 'p. λ 'k. prim.symbol-or-eof prim.empty $ λ 'c. analyze p c.
    case false. left 〈 '0 ∝ nil; '1 ∝ cat:nil; 〉
    case true. right (k c)
|]

gsparser_displayRune = $gsundefined_value

gsparser_optional = [gs:value| λ 'p. parser.unit nothing <|> parser.map just p |]

gsmany = [gs:value| λ 'p. parser.unit nil <|> parser.map2 (:) p (many p) |]

gsparser_unary_or = $gslambda_value $ \ p -> $gsbcenter p

gsparser_or = $gslambda_value $ \ p0 -> $gsbcarg $ \ p1 -> $gsbcarg $ \ k ->
    $gsbcapply gsprimor [ $gsae $ $gsbcapply p0 [ $gsav k ], $gsae $ $gsbcapply p1 [ $gsav k ] ]

$gsdeclare difference-w gsparser_difference_w

gsparser_notFollowedBy = [gs:value| λ 'p. λ 'k. difference-w (k 〈〉) (p prim.unit) |]

$gsdeclare prim.unit-plus gsprim_unit_plus
$gsdeclare prim.lookahead gsprim_lookahead

$gsdeclare negate-w gsparser_negate_w

gsparser_difference_w = [gs:value| λ 'p0. λ 'p1. analyze p0.
    case prim.unit-plus 'x 'p01. prim.lookahead (negate-w p1 (prim.unit-plus x p01))
|]

gsparser_negate_w = [gs:value| λ 'p. λ 'x. analyze p.
    case prim.unit-plus 'x 'p1. prim.empty
    case prim.symbol-or-eof 'ek 'sk. prim.symbol-or-eof undefined (λ 'c. analyze sk c.
        case left 'e. right (prim.unit x)
        case right 'p1. right (negate-w p1 x)
    )
|]

gsparser_getPos = $gslambda_value $ \ k -> $gsbcconstr (gsvar "get-pos") [ $gsav k ]

gsempty = $gslambda_value $ \ k -> $gsbcenter gsprim_empty

gsprimunit = $gslambda_value $ \ x -> $gsbcconstr (gsvar "unit-plus") [ $gsav x, $gsav gsprim_empty ]

gsprimor = [gs:value| λ 'p0. λ 'p1. analyze p0.
    case prim.empty. p1
    case prim.unit-plus 'x 'p01. prim.unit-plus x (prim.<|> p01 p1)
    case prim.get-pos 'k0. (analyze p1.
        case prim.empty. get-pos k0
        case prim.symbol-or-eof 'ek1 'sk1. get-pos (λ 'pos. prim.<|> (k0 pos) (prim.symbol-or-eof ek1 sk1))
    )
    case prim.lookahead 'p01. (analyze p1.
        case prim.symbol-or-eof 'ek1 'sk1. prim.lookahead (prim.<|> p01 (prim.unit (p1)))
    )
    case prim.symbol-or-eof 'ek0 'sk0. (analyze p1.
        case prim.empty. p0
        case prim.unit-plus 'x 'p11. prim.unit-plus x (prim.<|> p0 p11)
        case prim.symbol-or-eof 'ek1 'sk1. prim.symbol-or-eof (prim.<|> ek0 ek1) (λ 'c. analyze sk0 c.
            case left 'e0. (analyze sk1 c.
                case left 'e1. left 〈 '0 ∝ undefined; '1 ∝ undefined; 〉
                case right 'p3. right p3
            )
            case right 'p2. (analyze sk1 c.
                case left 'e1. right p2
            )
        )
    )
|]

gsprim_empty = $gsconstr (gsvar "empty") []
gsprim_unit_plus = $gslambda_value $ \ x -> $gsbcarg $ \ p -> $gsbcconstr (gsvar "unit-plus") [ $gsav x, $gsav p ]
gsprim_lookahead = $gslambda_value $ \ p -> $gsbcconstr (gsvar "lookahead") [ $gsav p ]
gsprim_symbol = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcconstr (gsvar "symbol-or-eof") [ $gsav ek, $gsav sk ]

gsprim_empty_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "empty" ek sk e
gsprim_unit_plus_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "unit-plus" ek sk e
gsprim_get_pos_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "get-pos" ek sk e
gsprim_lookahead_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "lookahead" ek sk e
gsprim_symbol_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "symbol-or-eof" ek sk e

gsparser_advanceRune = $gslambda_value $ \ c -> $gsbcarg $ \ pos -> [gs:expr hsvs=c,pos,| analyze rune.≡ c r{\n}.
    case true. 〈 'filename ∝ pos #filename; 'line ∝ pos #line + 1; 'col ∝ 1; 〉
    case false. 〈 'filename ∝ pos #filename; 'line ∝ pos #line; 'col ∝ pos #col + 1; 〉
|]

gsparser_print_rune = [gs:value| λ 'c. qq{'§(c:nil)'} |]
