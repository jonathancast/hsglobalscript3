{-# LANGUAGE TemplateHaskell #-}
module GSI.Parser (gsparse, gsposFmt, gsparserFor, gsparser_then, gsparser_unary_then, gsparser_bind, gsparser_map, gsparser_unit, gsparser_map2, gsparser_matching, gsparser_string, gsparser_char, gsparser_optional, gsmany, gsparser_unary_or, gsparser_or, gsparser_getPos, gsempty, gsempty_view, gsparser_advanceRune) where

import GSI.Syn (gsvar)
import GSI.Value (GSValue, gslambda_value, gsconstr, gsundefined_value, gsav, gsae)
import GSI.ByteCode (gsbcarg, gsbcenter, gsbcapply, gsbcconstr, gsbcundefined, gsbcconstr_view)
import GSI.List (gsnil, gscons)
$gsimports

gsparse = $gslambda_value $ \ adv -> $gsbcarg $ \ p -> $gsbcarg $ \ pos -> $gsbcarg $ \ s ->
    [gs:expr hsvs=gsparsew,adv,p,gsprimunit,pos,s,| gsparsew adv (p gsprimunit) pos s |]

gsparsew = $gslambda_value $ \ adv -> $gsbcarg $ \ p -> $gsbcarg $ \ pos -> $gsbcarg $ \ s -> [gs:expr hsvs=gsparsew,gsfmtError,adv,p,pos,s,| analyze p.
    case empty. left (pos.fmt pos qq{empty})
    case unit-plus 'x 'p1. (analyze s.
        case nil. right x
        case _:_. gsparsew adv p1 pos s
    )
    case get-pos 'k. gsparsew adv (k pos) pos s
    case symbol-or-eof 'ek 'sk. (analyze s.
        case 'c:'s1. (analyze sk c.
            case left 'e. left (pos.fmt pos (gsfmtError (e #0) (e #1)))
            case right 'p1. gsparsew adv p1 (adv c pos) s1
        )
    )
|]

gsposFmt :: GSValue
gsposFmt = $gslambda_value $ \ pos -> $gsbcarg $ \ msg ->
    [gs:expr hsvs=pos,msg,| qq{§(pos #filename):§(fmtdecimal (pos #line)):§(fmtdecimal (pos #col)): §(msg)} |]

gsfmtError = [gs:value| undefined |]

gsparserFor = $gslambda_value $ \ gens -> $gsbcarg $ \ e -> $gsbcapply gsparser_bind [ $gsav gens, $gsav e ]

gsparser_bind = $gslambda_value $ \ p -> $gsbcarg $ \ f -> $gsbcarg $ \ k -> $gsbcapply p [ $gsae $ $gsbcarg $ \ x ->
    $gsbcapply f [ $gsav x, $gsav k ] ]

gsparser_then = $gslambda_value $ \ p0 -> $gsbcarg $ \ p1 -> $gsbcarg $ \ k -> $gsbcapply p0 [ $gsae $ $gsbcarg $ \ _ -> $gsbcapply p1 [ $gsav k ] ]

gsparser_unary_then = $gslambda_value $ \ p0 -> $gsbcenter p0

gsparser_map = [gs:value| λ 'f. λ 'p. λ 'k. p (λ 'x. k (f x)) |]

gsparser_unit = $gslambda_value $ \ x -> $gsbcarg $ \ k -> $gsbcapply k [ $gsav x ]

gsparser_map2 = $gslambda_value $ \ f -> $gsbcarg $ \ p0 -> $gsbcarg $ \ p1 -> $gsbcarg $ \ k ->
    [gs:expr hsvs=f,p0,p1,k,| p0 (λ 'x0. p1 (λ 'x1. k (f x0 x1))) |]

gsparser_string = $gslambda_value $ \ s -> [gs:expr hsvs=s,| analyze s.
    case 'c:'s1. char c *> string s1
    case nil. parser.unit 〈〉
|]

gsparser_char = $gslambda_value $ \ ch -> [gs:expr hsvs=ch,| matching (display-rune ch) (rune.≡ ch) |]

gsparser_matching = $gslambda_value $ \ cat -> $gsbcarg $ \ p -> $gsbcarg $ \ k ->
    $gsbcconstr (gsvar "symbol-or-eof") [ $gsae $gsbcundefined, $gsae $ $gsbcarg $ \ c ->
        [gs:expr hsvs=p,c,k,| analyze p c.
            case false. left 〈 '0 ∝ undefined; '1 ∝ undefined; 〉
            case true. right (k c)
        |]
    ]

gsparser_displayRune = $gsundefined_value

gsparser_optional = [gs:value| λ 'p. parser.unit undefined <|> parser.map undefined p |]

gsmany = $gslambda_value $ \ p -> $gsbcapply gsparser_or [
    $gsae $ $gsbcapply gsparser_unit [ $gsav gsnil ],
    $gsae $ $gsbcapply gsparser_map2 [ $gsav [gs:value| (:) |], $gsav p, $gsae $ $gsbcapply gsmany [ $gsav p ] ]
  ]

gsparser_unary_or = $gslambda_value $ \ p -> $gsbcenter p

gsparser_or = $gslambda_value $ \ p0 -> $gsbcarg $ \ p1 -> $gsbcarg $ \ k ->
    $gsbcapply gsprimor [ $gsae $ $gsbcapply p0 [ $gsav k ], $gsae $ $gsbcapply p1 [ $gsav k ] ]

gsparser_getPos = $gslambda_value $ \ k -> $gsbcconstr (gsvar "get-pos") [ $gsav k ]

gsempty = $gslambda_value $ \ k -> $gsbcenter gsprimempty

gsprimunit = $gslambda_value $ \ x -> $gsbcconstr (gsvar "unit-plus") [ $gsav x, $gsav gsprimempty ]

gsprimor = $gslambda_value $ \ p0 -> $gsbcarg $ \ p1 -> [gs:expr hsvs=gsprimor,gsprimunitplus,gsprimsymbol,p0,p1,| analyze p0.
    case empty. p1
    case unit-plus 'x 'p01. gsprimunitplus x (gsprimor p01 p1)
    case get-pos 'k0. (analyze p1.
        case empty. get-pos k0
        case symbol-or-eof 'ek1 'sk1. get-pos (λ 'pos. gsprimor (k0 pos) (gsprimsymbol ek1 sk1))
    )
    case symbol-or-eof 'ek0 'sk0. (analyze p1.
        case symbol-or-eof 'ek1 'sk1. gsprimsymbol undefined (λ 'c. analyze sk0 c.
            case left 'e0. (analyze sk1 c.
                case left 'e1. left 〈 '0 ∝ undefined; '1 ∝ undefined; 〉
                case right 'p3. right p3
            )
            case right 'p2. (analyze sk1 c.
                case left 'e1. right p2
            )
        )
    )
|]

gsprimempty = $gsconstr (gsvar "empty") []
gsprimunitplus = $gslambda_value $ \ x -> $gsbcarg $ \ p -> $gsbcconstr (gsvar "unit-plus") [ $gsav x, $gsav p ]
gsprimsymbol = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcconstr (gsvar "symbol-or-eof") [ $gsav ek, $gsav sk ]

gsempty_view :: GSValue
gsempty_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "empty" ek sk e

gsunitplus_view :: GSValue
gsunitplus_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "unit-plus" ek sk e

gsparser_getPos_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "get-pos" ek sk e

gssymbol_view :: GSValue
gssymbol_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "symbol-or-eof" ek sk e

gsparser_advanceRune = $gslambda_value $ \ c -> $gsbcarg $ \ pos -> [gs:expr hsvs=c,pos,| analyze rune.≡ c r{\n}.
    case true. 〈 'filename ∝ pos #filename; 'line ∝ pos #line + 1; 'col ∝ 1; 〉
    case false. 〈 'filename ∝ pos #filename; 'line ∝ pos #line; 'col ∝ pos #col + 1; 〉
|]
