{-# LANGUAGE TemplateHaskell #-}
module GSI.Parser (gsparse, gsposFmt, gsparserFor, gsparser_bind, gsparser_map, gsparser_unit, gsmany, gsparser_unary_or, gsempty, gsempty_view) where

import GSI.Syn (gsvar)
import GSI.Value (GSValue, gslambda, gsconstr, gsundefined_value, gsav, gsae)
import GSI.ByteCode (gsbcarg, gsbcenter, gsbcapply, gsbcconstr, gsbcundefined, gsbcconstr_view)
import GSI.List (gsnil)
$gsimports

gsparse = $gslambda $ \ p -> $gsbcarg $ \ pos -> $gsbcarg $ \ s ->
    [gs:expr hsvs=gsparsew,p,gsprimunit,pos,s,| gsparsew (p gsprimunit) pos s |]

gsparsew = $gslambda $ \ p -> $gsbcarg $ \ pos -> $gsbcarg $ \ s -> [gs:expr hsvs=gsparsew,p,pos,s,| analyze p.
    case empty. left (pos.fmt pos qq{empty})
    case unit-plus 'x 'p1. (analyze s.
        case nil. right x
        case _:_. gsparsew p1 pos s
    )
|]

gsposFmt :: GSValue
gsposFmt = $gslambda $ \ pos -> $gsbcarg $ \ msg ->
    [gs:expr hsvs=pos,msg,| qq{ยง(pos #filename):ยง(fmtdecimal (pos #line)):ยง(fmtdecimal (pos #col)): ยง(msg)} |]

gsparserFor = $gslambda $ \ gens -> $gsbcarg $ \ e -> $gsbcapply gsparser_bind [ $gsav gens, $gsav e ]

gsparser_bind = $gslambda $ \ p -> $gsbcarg $ \ f -> $gsbcarg $ \ k -> $gsbcapply p [ $gsae $ $gsbcarg $ \ x ->
    $gsbcapply f [ $gsav x, $gsav k ] ]

gsparser_map = $gslambda $ \ f -> $gsbcarg $ \ p -> $gsbcarg $ \ k -> $gsbcapply p [ $gsae $ $gsbcarg $ \ x ->
    $gsbcapply k [ $gsae $ $gsbcundefined ] ]

gsparser_unit = $gslambda $ \ x -> $gsbcarg $ \ k -> $gsbcapply k [ $gsav x ]

gsmany = $gslambda $ \ p -> $gsbcapply gsparser_or [
    $gsae $ $gsbcapply gsparser_unit [ $gsav gsnil ],
    $gsae $ $gsbcundefined
  ]

gsparser_unary_or = $gslambda $ \ p -> $gsbcenter p

gsparser_or = $gslambda $ \ p0 -> $gsbcarg $ \ p1 -> $gsbcarg $ \ k ->
    $gsbcapply gsprimor [ $gsae $ $gsbcapply p0 [ $gsav k ], $gsae $ $gsbcundefined ]

gsempty = $gslambda $ \ k -> $gsbcenter gsprimempty

gsprimunit = $gslambda $ \ x -> $gsbcconstr (gsvar "unit-plus") [ $gsav x, $gsav gsprimempty ]

gsprimor = $gslambda $ \ p0 -> $gsbcarg $ \ p1 -> [gs:expr hsvs=p0,p1,| analyze p0.
    case unit-plus 'x 'p01. (analyze p1.
    )
|]

gsprimempty = $gsconstr (gsvar "empty") []

gsempty_view :: GSValue
gsempty_view = $gslambda $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "empty" ek sk e

gsunitplus_view :: GSValue
gsunitplus_view = $gslambda $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "unit-plus" ek sk e
