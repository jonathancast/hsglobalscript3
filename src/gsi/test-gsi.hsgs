{-# LANGUAGE TemplateHaskell #-}

import Control.Concurrent.MVar (MVar, newMVar)
import Control.Exception (SomeException, catch, displayException)

import System.Environment (getArgs)
import System.Exit (ExitCode(..), exitWith)
import System.IO (hPutStrLn, stderr)

import Component.Monad (mvarContents)

import GSI.Util (fmtPos, gshere)
import GSI.Value (GSValue, gsapply, gsundefined_value)
import GSI.ThreadType (ThreadData(..), fetchThreadDataComponent, insertThreadDataComponent, emptyThreadDataComponents)
import GSI.Thread (createThread, execMainThread)
import GSI.Functions (gslist, gsstring)
import GSI.Env (GSEnvArgs(..))
import GSI.Main (gsmain)
$gsimports

main = do
    as <- newMVar . GSEnvArgs . $gslist . map $gsstring =<< getArgs
    prog <- $gsapply gsmain [gstyc, gsrun]
    t <- createThread $gshere (testGSIThreadData TestGSIThread{ envArgs = as }) prog Nothing
    execMainThread t
  `catch` \ e -> hPutStrLn stderr (displayException (e :: SomeException)) >> exitWith (ExitFailure 1) -- Because Haskell is a conspiracy to avoid good error messages

gstyc = [gs:value| λ 'ty. type-checker.unit 〈〉 |]

gsrun = [gs:value| λ 'x. λ 'as. analyze x.
    case _. (analyze-impM gseval-sync x.
        case gsresult.error 'e. impfor _ ← print-error qq{§(gsfmt-error e)\n};. error log{Errors next}
    )
|]

data TestGSIThread = TestGSIThread{
    envArgs :: MVar GSEnvArgs
  }

testGSIThreadData :: TestGSIThread -> ThreadData
testGSIThreadData d = ThreadData{
    component = fetchThreadDataComponent testGSIThreadComponents d,
    threadTypeName = fmtPos $gshere "TestGSIThread"
  }

testGSIThreadComponents =
    insertThreadDataComponent (\d -> mvarContents (envArgs d)) $
    emptyThreadDataComponents
