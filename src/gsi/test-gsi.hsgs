{-# LANGUAGE TemplateHaskell #-}

import Control.Exception (SomeException, catch, displayException)

import System.Environment (getArgs)
import System.Exit (ExitCode(..), exitWith)
import System.IO (hPutStrLn, stderr)

import GSI.Util (fmtPos, gshere)
import GSI.Value (GSValue, gsapply, gsundefined_value)
import GSI.Thread (createThread, execMainThread)
import GSI.Functions (gslist, gsstring)
import GSI.Main (gsmain)
$gsimports

main = do
    as <- $gslist . map $gsstring <$> getArgs
    prog <- $gsapply gsmain [gstyc, gsrun, as]
    t <- createThread $gshere prog Nothing
    execMainThread t
  `catch` \ e -> hPutStrLn stderr (displayException (e :: SomeException)) >> exitWith (ExitFailure 1) -- Because Haskell is a conspiracy to avoid good error messages

gstyc = [gs:value| λ 'pos. λ 'ty. type-checker.unit 〈〉 |]

$gsdeclare gsrun gsrun
$gsdeclare gsprintstr gsprintstr

gsrun = [gs:value| λ 'x. λ 'as. analyze x.
    case gsvalue.error 'e. print qq{<Error: §(gsfmt-error e)>\n}
    case gsvalue.implementation-failure 'pos 'e. print qq{<Implementation failure: §(pos.fmt pos qq{§(e)})>\n}
    case gsvalue.natural 'n. print qq{§(natural.fmt-decimal n)\n}
    case gsvalue.function 'f. print qq{<function>\n}
    case gsvalue.constr 'pos 'v ('r : ('s : nil)). (analyze gsvar.≡ v (gsvar qq{:}).
        case true. impfor _ ← print qq{qq\{}; _ ← gsprintstr x;. print qq{\}}
    )
    case gsvalue.thunk 'th. impfor 'x1 ← gseval-sync th;. gsrun x1 as
|]

gsprintstr = [gs:value| λ 's. analyze s.
    case gsvalue.implementation-failure 'pos 'e. print qq{<Implementation failure: §(pos.fmt pos qq{§(e)})\n}
    case gsvalue.constr 'pos 'v ('r : ('s1 : nil)). (analyze gsvar.≡ v (gsvar qq{:}).
        case true. (analyze r.
            case gsvalue.implementation-failure 'pos 'e. impfor _ ← print qq{<Implementation failure: §(pos.fmt pos e)>};. gsprintstr s1
            case gsvalue.thunk 'th. impfor 'r1 ← gseval-sync th;. gsprintstr (gsvalue.constr pos v (r1 : s1 : nil))
            case gsvalue.rune 'r0. impfor _ ← print (r0 : nil);. gsprintstr s1
        )
    )
    case gsvalue.constr 'pos 'v nil. (analyze gsvar.≡ v (gsvar qq{nil}).
        case true. impunit 〈〉
    )
    case gsvalue.thunk 'th. impfor 's1 ← gseval-sync th;. gsprintstr s1
|]
