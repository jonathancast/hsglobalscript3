{-# LANGUAGE TemplateHaskell #-}
module GSDL.TypeCheck (gstype_check_document, gstype_check_expr) where

$gsimports

gstype_check_document = [gs:value| λ 'pos. λ 'gstyc. λ 'mbe. type-checker.for
        'ty ← type-checker.new-unifiable-var;
        'mbe1 ← analyze mbe.
            case nothing. type-checker.unit nothing
            case just 'e. type-checker.for 'e1 ← type-check-expr pos e ty;. type-checker.unit (just e1)
        ;
        _ ← gstyc pos ty;
    . type-checker.unit mbe1
|]

$gsdeclare type-check-pat gstype_check_pat

gstype_check_expr = [gs:value| λ 'pos. λ 'e. λ 'tye. analyze e.
    case expr.natural 'n. type-checker.for
            _ ← type-checker.unify pos (type.const (gsvar qq{natural.t})) tye;
        . type-checker.unit (expr.natural n)
    case expr.var 'v. type-checker.for
            'tya ← type-checker.env.get-type pos v;
            'tyai ← instantiate tya;
            'ims ← type-checker.env.get-implicit v;
            'imtys ← type-checker.mapM (λ _. type-checker.new-unifiable-var) ims;
            _ ← type-checker.unify pos tyai (foldr type.function tye imtys);
            'imas ← type-checker.zip-withM (type-check-implicit pos) ims imtys;
        . type-checker.unit (foldl expr.app (expr.var v) imas)
    case expr.app 'ef 'ex. type-checker.for
            'tyx ← type-checker.new-unifiable-var;
            'ef1 ← type-check-expr pos ef (type.function tyx tye);
            'ex1 ← type-check-arg pos ex tyx;
        . type-checker.unit (expr.app ef1 ex1)
    case expr.open-expr 'e1 (just 'bvs). type-checker.for
            'Γ1 ← type-checker.foldM
                (λ 'v. λ 'env1. type-checker.for 'tyv ← type-checker.new-unifiable-var;.
                    type-checker.unit (type.env.type.insert v tyv env1)
                )
                type.env.empty
                bvs
            ;
            'tye1 ← type-checker.new-unifiable-var;
            _ ← type-checker.unify pos (type.function (type.signature Γ1) tye1) tye;
            'e2 ← type-checker.with-type-env Γ1 $ type-check-expr pos e1 tye1;
        . type-checker.unit (expr.open-expr e2 (just bvs))
    case expr.pat 'p (just 'bvs). type-checker.for
            'Γ1 ← type-checker.foldM
                (λ 'v. λ 'env1. type-checker.for 'tyv ← type-checker.new-unifiable-var;.
                    type-checker.unit (type.env.type.insert v tyv env1)
                )
                type.env.empty
                bvs
            ;
            'τ0 ← type-checker.new-unifiable-var;
            _ ← type-checker.unify pos (type.function τ0 (type.signature Γ1)) tye;
            'p1 ← type-check-pat pos p τ0 Γ1;
        . type-checker.unit (expr.pat p1 (just bvs))
    case expr.monoidal-pat 'p (just 'bvs). type-checker.for
            'Γ1 ← type-checker.foldM
                (λ 'v. λ 'env1. type-checker.for 'tyv ← type-checker.new-unifiable-var;.
                    type-checker.unit (type.env.type.insert v tyv env1)
                )
                type.env.empty
                bvs
            ;
            'τ0 ← type-checker.new-unifiable-var;
            _ ← type-checker.unify pos (type.function τ0 (type.app (type.const (gsvar qq{generator.monoidal.t})) (type.signature Γ1))) tye;
            'p1 ← type-check-pat pos p τ0 Γ1;
        . type-checker.unit (expr.pat p1 (just bvs))
    case expr.missing-case. type-checker.for
            'τ0 ← type-checker.new-unifiable-var;
            'τ1 ← type-checker.new-unifiable-var;
            _ ← type-checker.unify pos (type.function τ0 τ1) tye;
        . type-checker.unit expr.missing-case
|]

gstype_check_implicit = [gs:value| λ 'pos. λ 'im. λ 'ty. analyze im.
    case implicit.here. type-checker.for
            _ ← type-checker.unify pos (type.const (gsvar qq{stack-trace.t})) ty;
        . type-checker.unit arg.here
|]

gstype_check_arg = [gs:value| λ 'pos. λ 'a. λ 'ty. analyze a.
    case arg.expr 'pos1 'e. type-checker.map (arg.expr pos1) (type-check-expr pos1 e ty)
|]

gstype_check_pat = [gs:value| λ 'pos. λ 'p. λ 'typ. λ 'env. analyze p.
    case pat.var 'v. (analyze type.env.type.get v env.
        case just 'tya. type-checker.for _ ← type-checker.unify pos tya typ;. type-checker.unit (pat.var v)
    )
|]
