{-# LANGUAGE TemplateHaskell #-}
module GSDL.TypeCheck (gstype_check_document, gstype_check_expr) where

$gsimports

gstype_check_document = [gs:value| λ 'pos. λ 'gstyc. λ 'd. analyze d.
    case document.in 'mbe 'mbg. type-checker.for
            'ty ← type-checker.new-unifiable-var;
            'mbg1 ← analyze mbg.
                case nothing. type-checker.unit nothing
            ;
            'mbe1 ← analyze mbe.
                case nothing. type-checker.unit nothing
                case just 'e. type-checker.for 'e1 ← type-check-expr pos e ty;. type-checker.unit (just e1)
            ;
            _ ← gstyc pos ty;
        . type-checker.unit (document.in mbe1 mbg1)
|]

$gsdeclare type-check-pat gstype_check_pat
$gsdeclare new-env gsnew_env

gstype_check_expr = [gs:value| λ 'pos. λ 'e. λ 'tye. analyze e.
    case expr.natural 'n. type-checker.for
            _ ← type-checker.unify pos (type.const (gsvar qq{natural.t})) tye;
        . type-checker.unit (expr.natural n)
    case expr.var 'v. type-checker.for
            'tya ← type-checker.env.get-type pos v;
            'tyai ← instantiate tya;
            'ims ← type-checker.env.get-implicit v;
            'imtys ← type-checker.mapM (λ _. type-checker.new-unifiable-var) ims;
            _ ← type-checker.unify pos tyai (foldr type.function tye imtys);
            'imas ← type-checker.zip-withM (type-check-implicit pos) ims imtys;
        . type-checker.unit (foldl expr.app (expr.var v) imas)
    case expr.qlo 'v 'e 'x. type-checker.for
            'x1 ← e #type-check pos x tye;
        . type-checker.unit (expr.qlo v e x1)
    case expr.app 'ef 'ex. type-checker.for
            'tyx ← type-checker.new-unifiable-var;
            'ef1 ← type-check-expr pos ef (type.function tyx tye);
            'ex1 ← type-check-arg pos ex tyx;
        . type-checker.unit (expr.app ef1 ex1)
    case expr.open-expr 'e1 (just 'bvs). type-checker.for
            'Γ1 ← new-env bvs;
            'tye1 ← type-checker.new-unifiable-var;
            _ ← type-checker.unify pos (type.function (type.signature Γ1) tye1) tye;
            'e2 ← type-checker.with-type-env Γ1 $ type-check-expr pos e1 tye1;
        . type-checker.unit (expr.open-expr e2 (just bvs))
    case expr.pat 'p (just 'bvs). type-checker.for
            'Γ1 ← new-env bvs;
            'τ0 ← type-checker.new-unifiable-var;
            _ ← type-checker.unify pos (type.function τ0 (type.signature Γ1)) tye;
            'p1 ← type-check-pat pos p τ0 Γ1;
        . type-checker.unit (expr.pat p1 (just bvs))
    case expr.monoidal-pat 'p (just 'bvs). type-checker.for
            'Γ1 ← new-env bvs;
            'τ0 ← type-checker.new-unifiable-var;
            _ ← type-checker.unify pos (type.function τ0 (type.app (type.const (gsvar qq{generator.monoidal.t})) (type.signature Γ1))) tye;
            'p1 ← type-check-pat pos p τ0 Γ1;
        . type-checker.unit (expr.monoidal-pat p1 (just bvs))
    case expr.missing-case. type-checker.for
            'τ0 ← type-checker.new-unifiable-var;
            'τ1 ← type-checker.new-unifiable-var;
            _ ← type-checker.unify pos (type.function τ0 τ1) tye;
        . type-checker.unit expr.missing-case
|]

gsnew_env = [gs:value|
    type-checker.foldM (λ 'v. λ 'env1. type-checker.for 'tyv ← type-checker.new-unifiable-var;. type-checker.unit (type.env.type.insert v tyv env1)) type.env.empty
|]

gstype_check_implicit = [gs:value| λ 'pos. λ 'im. λ 'ty. analyze im.
    case implicit.here. type-checker.for
            _ ← type-checker.unify pos (type.const (gsvar qq{stack-trace.t})) ty;
        . type-checker.unit arg.here
|]

gstype_check_arg = [gs:value| λ 'pos. λ 'a. λ 'ty. analyze a.
    case arg.expr 'pos1 'e. type-checker.map (arg.expr pos1) (type-check-expr pos1 e ty)
    case arg.explicit 'pos1 'e. type-checker.map (arg.explicit pos1) (type-check-expr pos1 e ty)
|]

gstype_check_pat = [gs:value| λ 'pos. λ 'p. λ 'typ. λ 'env. analyze p.
    case pat.discard. type-checker.unit pat.discard
    case pat.var 'v. (analyze type.env.type.get v env.
        case just 'tya. type-checker.for _ ← type-checker.unify pos tya typ;. type-checker.unit (pat.var v)
    )
    case pat.view 'v. type-checker.for
            'tya ← type-checker.env.get-view-type pos v;
            'tyai ← instantiate tya;
            _ ← type-checker.unify pos tyai typ;
        . type-checker.unit (pat.view v)
    case pat.app 'p0 'pos1 'p1. type-checker.for
            'tyx ← type-checker.new-unifiable-var;
            'ef1 ← type-check-pat pos p0 (type.function tyx typ) env;
            'ex1 ← type-check-pat pos1 p1 tyx env;
        . type-checker.unit (pat.app p0 pos1 p1)
|]
