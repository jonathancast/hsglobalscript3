{-# LANGUAGE TemplateHaskell #-}
module GSDL.AST (
    gstype_env_type_get, gstype_env_type_insert, gstype_env_types, gstype_env_vars, gstype_env_view_type_get, gstype_env_view_type_insert, gstype_env_views, gstype_env_implicits_get, gstype_env_implicits_insert, gstype_env_overlay, gstype_env_empty,
    gsfile_document, gsfile_document_view,
    gsdocument_in, gsdocument_in_view,
    gstype_unifiable_var, gstype_const, gstype_signature, gstype_empty_signature, gstype_forall, gstype_app, gstype_function,
    gstype_unifiable_var_view, gstype_const_view, gstype_signature_view, gstype_forall_view, gstype_app_view, gstype_function_view,
    gskind_pointed,
    gsexpr_natural, gsexpr_var, gsexpr_app, gsexpr_open_expr, gsexpr_pat, gsexpr_monoidal_pat, gsexpr_missing_case, gsexpr_natural_view, gsexpr_var_view, gsexpr_app_view, gsexpr_open_expr_view, gsexpr_pat_view, gsexpr_monoidal_pat_view, gsexpr_missing_case_view,
    gsimplicit_here, gsimplicit_here_view,
    gsarg_expr, gsarg_here, gsarg_expr_view, gsarg_here_view,
    gspat_discard, gspat_discard_view, gspat_var, gspat_view, gspat_var_view, gspat_view_view, gspat_app, gspat_app_view,
    gsorder_of_being_open_expr, gsorder_of_being_open_expr_view, gsorder_of_being_pattern, gsorder_of_being_pattern_view,
    gscategory_monoidal, gscategory_monoidal_view,
    gssyntactic_category_lambda_like, gssyntactic_category_variable, gssyntactic_category_lambda_like_view, gssyntactic_category_variable_view
  ) where

import GSI.Syn (gsvar)
import GSI.Value (gslambda_value, gsconstr, gsav)
import GSI.ByteCode (gsbcarg, gsbcconstr, gsbcconstr_view)
$gsimports

gstype_env_type_get = [gs:value| λ 'v. λ 'env. ordered-map.get gsvar.compare v (env #types) |]

gstype_env_type_insert = [gs:value| λ 'v. λ 'ty. λ 'env. 〈
    'types ∝ ordered-map.insert gsvar.compare v ty (env #types);
    'view-types ∝ env #view-types;
    'implicits ∝ env #implicits;
〉 |]

gstype_env_types = [gs:value| λ 'env. ordered-map.values (env #types) <> ordered-map.values (env #view-types) |]

gstype_env_vars = [gs:value| λ 'env. ordered-map.keys (env #types) |]

gstype_env_view_type_get = [gs:value| λ 'v. λ 'env. ordered-map.get gsvar.compare v (env #view-types) |]

gstype_env_view_type_insert = [gs:value| λ 'v. λ 'ty. λ 'env. 〈
    'types ∝ env #types;
    'view-types ∝ ordered-map.insert gsvar.compare v ty (env #view-types);
    'implicits ∝ env #implicits;
〉 |]

gstype_env_views = [gs:value| λ 'env. ordered-map.keys (env #view-types) |]

gstype_env_implicits_get = [gs:value| λ 'v. λ 'env. analyze ordered-map.get gsvar.compare v (env #implicits).
    case nothing. nil
    case just 'is. is
|]

gstype_env_implicits_insert = [gs:value| λ 'v. λ 'is. λ 'env. 〈
    'types ∝ env #types;
    'view-types ∝ env #view-types;
    'implicits ∝ ordered-map.insert gsvar.compare v is (env #implicits);
〉 |]

gstype_env_overlay = [gs:value| λ 'env0. λ 'env1. 〈
    'types ∝ ordered-map.∪ gsvar.compare (env0 #types) (env1 #types);
    'view-types ∝ ordered-map.∪ gsvar.compare (env0 #view-types) (env1 #view-types);
    'implicits ∝ ordered-map.∪ gsvar.compare (env0 #implicits) (env1 #implicits);
〉 |]

gstype_env_empty = [gs:value| 〈 'types ∝ ordered-map.empty; 'view-types ∝ ordered-map.empty; 'implicits ∝ ordered-map.empty; 〉 |]

gsfile_document = $gslambda_value $ \ pos -> $gsbcarg $ \ d -> $gsbcconstr (gsvar "document") [ $gsav pos, $gsav d ]

gsfile_document_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "document" ek sk e

gsdocument_in = $gslambda_value $ \ mbe -> $gsbcarg $ \ mbg -> $gsbcconstr (gsvar "in") [ $gsav mbe, $gsav mbg ]

gsdocument_in_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "in" ek sk e

gstype_empty_signature = [gs:value| type.signature type.env.empty |]

gstype_unifiable_var = $gslambda_value $ \ r -> $gsbcconstr (gsvar "unifiable-var") [ $gsav r ]
gstype_const = $gslambda_value $ \ c -> $gsbcconstr (gsvar "const") [ $gsav c ]
gstype_signature = $gslambda_value $ \ env -> $gsbcconstr (gsvar "signature") [ $gsav env ]
gstype_forall = $gslambda_value $ \ v -> $gsbcarg $ \ ki -> $gsbcarg $ \ ty1 -> $gsbcconstr (gsvar "forall") [ $gsav v, $gsav ki, $gsav ty1 ]
gstype_app = $gslambda_value $ \ ty0 -> $gsbcarg $ \ ty1 -> $gsbcconstr (gsvar "app") [ $gsav ty0, $gsav ty1 ]
gstype_function = $gslambda_value $ \ ty0 -> $gsbcarg $ \ ty1 -> $gsbcconstr (gsvar "function") [ $gsav ty0, $gsav ty1 ]

gstype_unifiable_var_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ ty -> $gsbcconstr_view "unifiable-var" ek sk ty
gstype_const_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ ty -> $gsbcconstr_view "const" ek sk ty
gstype_signature_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ ty -> $gsbcconstr_view "signature" ek sk ty
gstype_app_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ ty -> $gsbcconstr_view "app" ek sk ty
gstype_function_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ ty -> $gsbcconstr_view "function" ek sk ty
gstype_forall_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ ty -> $gsbcconstr_view "forall" ek sk ty

gskind_pointed = $gsconstr (gsvar "pointed") []

gsexpr_natural = $gslambda_value $ \ n -> $gsbcconstr (gsvar "natural") [ $gsav n ]
gsexpr_var = $gslambda_value $ \ id -> $gsbcconstr (gsvar "var") [ $gsav id ]
gsexpr_app = $gslambda_value $ \ fe -> $gsbcarg $ \ xe -> $gsbcconstr (gsvar "app") [ $gsav fe, $gsav xe ]
gsexpr_open_expr = $gslambda_value $ \ e -> $gsbcarg $ \ mb -> $gsbcconstr (gsvar "open-expr") [ $gsav e, $gsav mb ]
gsexpr_pat = $gslambda_value $ \ p -> $gsbcarg $ \ mb -> $gsbcconstr (gsvar "pat") [ $gsav p, $gsav mb ]
gsexpr_monoidal_pat = $gslambda_value $ \ p -> $gsbcarg $ \ mb -> $gsbcconstr (gsvar "monoidal-pat") [ $gsav p, $gsav mb ]
gsexpr_missing_case = $gsconstr (gsvar "missing-case") []

gsexpr_natural_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "natural" ek sk e
gsexpr_var_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "var" ek sk e
gsexpr_app_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "app" ek sk e
gsexpr_open_expr_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "open-expr" ek sk e
gsexpr_pat_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "pat" ek sk e
gsexpr_monoidal_pat_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "monoidal-pat" ek sk e
gsexpr_missing_case_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "missing-case" ek sk e

gsimplicit_here = $gsconstr (gsvar "here") []

gsimplicit_here_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ im -> $gsbcconstr_view "here" ek sk im

gsarg_expr = $gslambda_value $ \ pos -> $gsbcarg $ \ e -> $gsbcconstr (gsvar "expr") [ $gsav pos, $gsav e ]
gsarg_here = $gsconstr (gsvar "here") []

gsarg_expr_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ im -> $gsbcconstr_view "expr" ek sk im
gsarg_here_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ im -> $gsbcconstr_view "here" ek sk im

gspat_discard = $gsconstr (gsvar "discard") []
gspat_var = $gslambda_value $ \ v -> $gsbcconstr (gsvar "var") [ $gsav v ]
gspat_view = $gslambda_value $ \ v -> $gsbcconstr (gsvar "view") [ $gsav v ]
gspat_app = $gslambda_value $ \ p0 -> $gsbcarg $ \ pos -> $gsbcarg $ \ p1 -> $gsbcconstr (gsvar "app") [ $gsav p0, $gsav pos, $gsav p1 ]

gspat_discard_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ p -> $gsbcconstr_view "discard" ek sk p
gspat_var_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ p -> $gsbcconstr_view "var" ek sk p
gspat_view_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ p -> $gsbcconstr_view "view" ek sk p
gspat_app_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ p -> $gsbcconstr_view "app" ek sk p

gsorder_of_being_open_expr = $gsconstr (gsvar "open-expr") []
gsorder_of_being_pattern = $gsconstr (gsvar "pattern") []

gscategory_monoidal = $gsconstr (gsvar "monoidal") []
gscategory_monoidal_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ im -> $gsbcconstr_view "monoidal" ek sk im

gsorder_of_being_open_expr_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ im -> $gsbcconstr_view "open-expr" ek sk im
gsorder_of_being_pattern_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ im -> $gsbcconstr_view "pattern" ek sk im

gssyntactic_category_lambda_like = $gsconstr (gsvar "lambda-like") []
gssyntactic_category_variable = $gsconstr (gsvar "variable") []

gssyntactic_category_lambda_like_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ c -> $gsbcconstr_view "lambda-like" ek sk c
gssyntactic_category_variable_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ c -> $gsbcconstr_view "variable" ek sk c
