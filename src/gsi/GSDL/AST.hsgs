{-# LANGUAGE TemplateHaskell #-}
module GSDL.AST (
    gstype_env_type_get, gstype_env_type_insert, gstype_env_types, gstype_env_vars, gstype_env_implicits_get, gstype_env_implicits_insert, gstype_env_overlay, gstype_env_empty,
    gsfileDocument, gsfileDocument_view,
    gstype_unifiable_var, gstype_const, gstype_signature, gstype_empty_signature, gstype_forall, gstype_app, gstype_function,
    gstype_unifiable_var_view, gstype_const_view, gstype_signature_view, gstype_empty_signature_view, gstype_forall_view, gstype_app_view, gstype_function_view,
    gskind_pointed,
    gsexpr_natural, gsexpr_var, gsexpr_app, gsexpr_open_expr, gsexpr_pat, gsexpr_monoidal_pat, gsexpr_missing_case, gsexpr_natural_view, gsexpr_var_view, gsexpr_app_view, gsexpr_open_expr_view, gsexpr_pat_view, gsexpr_missing_case_view,
    gsimplicit_here, gsimplicit_here_view,
    gsarg_expr, gsarg_here, gsarg_expr_view, gsarg_here_view,
    gspat_var, gspat_view, gspat_var_view, gspat_view_view,
    gsorder_of_being_open_expr, gsorder_of_being_open_expr_view, gsorder_of_being_pattern, gsorder_of_being_pattern_view,
    gscategory_monoidal
  ) where

import GSI.Syn (gsvar)
import GSI.Value (gslambda_value, gsconstr, gsav)
import GSI.ByteCode (gsbcarg, gsbcconstr, gsbcconstr_view)
$gsimports

gstype_env_type_get = [gs:value| λ 'v. λ 'env. ordered-map.get gsvar.compare v (env #types) |]

gstype_env_type_insert = [gs:value| λ 'v. λ 'ty. λ 'env. 〈
    'types ∝ ordered-map.insert gsvar.compare v ty (env #types);
    'implicits ∝ env #implicits;
〉 |]

gstype_env_types = [gs:value| λ 'env. ordered-map.values (env #types) |]

gstype_env_vars = [gs:value| λ 'env. ordered-map.keys (env #types) |]

gstype_env_implicits_get = [gs:value| λ 'v. λ 'env. analyze ordered-map.get gsvar.compare v (env #implicits).
    case nothing. nil
    case just 'is. is
|]

gstype_env_implicits_insert = [gs:value| λ 'v. λ 'is. λ 'env. 〈
    'types ∝ env #types;
    'implicits ∝ ordered-map.insert gsvar.compare v is (env #implicits);
〉 |]

gstype_env_overlay = [gs:value| λ 'env0. λ 'env1. 〈
    'types ∝ ordered-map.∪ gsvar.compare (env0 #types) (env1 #types);
    'implicits ∝ ordered-map.∪ gsvar.compare (env0 #implicits) (env1 #implicits);
〉 |]

gstype_env_empty = [gs:value| 〈 'types ∝ ordered-map.empty; 'implicits ∝ ordered-map.empty; 〉 |]

gstype_env_empty_view = [gs:value| λ 'ek. λ 'sk. λ 'env. analyze env #types.
    case ordered-map.empty. (analyze env #implicits.
        case ordered-map.empty. sk
        case _. ek
    )
    case _. ek
|]

gsfileDocument = $gslambda_value $ \ pos -> $gsbcarg $ \ mb -> $gsbcconstr (gsvar "document") [ $gsav pos, $gsav mb ]

gsfileDocument_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "document" ek sk e

gstype_empty_signature = [gs:value| type.signature type.env.empty |]

gstype_unifiable_var = $gslambda_value $ \ r -> $gsbcconstr (gsvar "unifiable-var") [ $gsav r ]
gstype_const = $gslambda_value $ \ c -> $gsbcconstr (gsvar "const") [ $gsav c ]
gstype_signature = $gslambda_value $ \ env -> $gsbcconstr (gsvar "signature") [ $gsav env ]
gstype_forall = $gslambda_value $ \ v -> $gsbcarg $ \ ki -> $gsbcarg $ \ ty1 -> $gsbcconstr (gsvar "forall") [ $gsav v, $gsav ki, $gsav ty1 ]
gstype_app = $gslambda_value $ \ ty0 -> $gsbcarg $ \ ty1 -> $gsbcconstr (gsvar "app") [ $gsav ty0, $gsav ty1 ]
gstype_function = $gslambda_value $ \ ty0 -> $gsbcarg $ \ ty1 -> $gsbcconstr (gsvar "function") [ $gsav ty0, $gsav ty1 ]

gstype_empty_signature_view = [gs:value| λ 'ek. λ 'sk. λ 'ty. analyze ty.
    case type.signature type.env.empty. sk
    case _. ek
|]

gstype_unifiable_var_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ ty -> $gsbcconstr_view "unifiable-var" ek sk ty
gstype_const_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ ty -> $gsbcconstr_view "const" ek sk ty
gstype_signature_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ ty -> $gsbcconstr_view "signature" ek sk ty
gstype_app_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ ty -> $gsbcconstr_view "app" ek sk ty
gstype_function_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ ty -> $gsbcconstr_view "function" ek sk ty
gstype_forall_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ ty -> $gsbcconstr_view "forall" ek sk ty

gskind_pointed = $gsconstr (gsvar "pointed") []

gsexpr_natural = $gslambda_value $ \ n -> $gsbcconstr (gsvar "natural") [ $gsav n ]
gsexpr_var = $gslambda_value $ \ id -> $gsbcconstr (gsvar "var") [ $gsav id ]
gsexpr_app = $gslambda_value $ \ fe -> $gsbcarg $ \ xe -> $gsbcconstr (gsvar "app") [ $gsav fe, $gsav xe ]
gsexpr_open_expr = $gslambda_value $ \ e -> $gsbcarg $ \ mb -> $gsbcconstr (gsvar "open-expr") [ $gsav e, $gsav mb ]
gsexpr_pat = $gslambda_value $ \ p -> $gsbcarg $ \ mb -> $gsbcconstr (gsvar "pat") [ $gsav p, $gsav mb ]
gsexpr_monoidal_pat = $gslambda_value $ \ p -> $gsbcarg $ \ mb -> $gsbcconstr (gsvar "monoidal-pat") [ $gsav p, $gsav mb ]
gsexpr_missing_case = $gsconstr (gsvar "missing-case") []

gsexpr_natural_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "natural" ek sk e
gsexpr_var_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "var" ek sk e
gsexpr_app_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "app" ek sk e
gsexpr_open_expr_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "open-expr" ek sk e
gsexpr_pat_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "pat" ek sk e
gsexpr_missing_case_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ e -> $gsbcconstr_view "missing-case" ek sk e

gsimplicit_here = $gsconstr (gsvar "here") []

gsimplicit_here_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ im -> $gsbcconstr_view "here" ek sk im

gsarg_expr = $gslambda_value $ \ pos -> $gsbcarg $ \ e -> $gsbcconstr (gsvar "expr") [ $gsav pos, $gsav e ]
gsarg_here = $gsconstr (gsvar "here") []

gsarg_expr_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ im -> $gsbcconstr_view "expr" ek sk im
gsarg_here_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ im -> $gsbcconstr_view "here" ek sk im

gspat_var = $gslambda_value $ \ v -> $gsbcconstr (gsvar "var") [ $gsav v ]
gspat_view = $gslambda_value $ \ v -> $gsbcconstr (gsvar "view") [ $gsav v ]

gspat_var_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ p -> $gsbcconstr_view "var" ek sk p
gspat_view_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ p -> $gsbcconstr_view "view" ek sk p

gsorder_of_being_open_expr = $gsconstr (gsvar "open-expr") []
gsorder_of_being_pattern = $gsconstr (gsvar "pattern") []

gscategory_monoidal = $gsconstr (gsvar "monoidal") []

gsorder_of_being_open_expr_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ im -> $gsbcconstr_view "open-expr" ek sk im
gsorder_of_being_pattern_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ im -> $gsbcconstr_view "pattern" ek sk im
