{-# LANGUAGE TemplateHaskell #-}
module GSDL.Syntax (file, pragmas, pragmawhitespace, expr, ident, ident_chars, op_chars, lexeme, whitespace) where

$gsimports

$gsdeclare document document

file = [gs:value| λ 'env.
    <|> parser.for
            _ ← pragmas;
            'pos ← get-pos;
            'd ← whitespace *> document env;
        . parser.unit (file.document pos d)
|]

pragmas = [gs:value| pragma.whitespace *> many empty |]

pragmawhitespace = [gs:value| many (
    <|> (
        *> string qq{#!}
        *> many (matching log{comment body character} (λ 'c. c ≠ r{\n}))
        *> char r{\n}
        *> parser.unit 〈〉
    )
    <|> (
        *> string qq{\n}
        *> parser.unit 〈〉
    )
) |]

$gsdeclare where-keyword where_keyword
$gsdeclare colon-paren colon_paren

$gsdeclare generator gsgenerator

document = [gs:value| λ 'env. parser.for
        'mbe ← optional (parser.for 'p ← expr env;. parser.unit (p #0));
        'mbw ← optional (
            *> lexeme (char r{,})
            *> where-keyword env
            *> colon-paren
            *> (generator env <* lexeme (char r{;}))
        );
    . parser.unit (document.in mbe mbw)
|]

$gsdeclare operator operator

$gsdeclare explicit-arg gsexplicit_arg

$gsdeclare expr.function gsexpr_function
$gsdeclare expr.lambda-like gsexpr_lambda_like

expr = [gs:value| λ 'env.
    <|> (parser.for 'pos0 ← get-pos; 'p0 ← expr.function env;.
        <|> parser.unit p0
        <|> parser.for
                'posop ← get-pos;
                'op ← operator env;
                's1 ← parser.unit $ parser.env.signature.get op env;
                'es ← many $ explicit-arg env;
                'opes ← parser.unit $ foldl expr.app (expr.var op) $ map (λ 'p. arg.explicit (p #0) (p #1)) es;
                'pos1 ← get-pos;
                'p1 ← expr.function env <|> expr.lambda-like env;
                's2 ← analyze s1.
                    case nil. parser.unit nil
                ;
            . parser.unit 〈 '0 ∝ expr.app (expr.app opes (arg.expr pos0 (p0 #0))) (arg.expr pos1 (p1 #0)); '1 ∝ s2; 〉
    )
    <|> expr.lambda-like env
|]

$gsdeclare expr.function.w gsexpr_function_w

gsexpr_function = [gs:value| λ 'env. parser.for 'p ← expr.atom true env;. expr.function.w env (p #0) (p #1) |]

$gsdeclare pat.atom gspat_atom

$gsdeclare arg-operator arg_operator

gsexpr_function_w = [gs:value| λ 'env. λ 'e. λ 's.
    <|> parser.unit 〈 '0 ∝ e; '1 ∝ s; 〉
    <|> (parser.for
            'pos ← get-pos;
            'p ← analyze s.
                case order-of-being.pattern : 's1. parser.for 'p ← pat.atom env;. parser.unit 〈 '0 ∝ arg.expr pos (expr.pat p nothing); '1 ∝ s1; 〉
                case order-of-being.value-var : 's1. parser.for 'i ← parser.map gsvar $ lexeme ident-chars;. parser.unit 〈 '0 ∝ arg.expr pos (expr.value-var i); '1 ∝ s1; 〉
                case nil.
                    <|> (parser.for 'p ← expr.atom false env;. parser.unit 〈 '0 ∝ arg.expr pos (p #0); '1 ∝ nil; 〉)
                    <|> (parser.for
                            'op ← arg-operator env;
                            'a ← analyze parser.env.signature.get op env.
                                case order-of-being.var-name : _. parser.for  'v ← ident;. parser.unit (arg.var-name v)
                            ;
                        . parser.unit 〈 '0 ∝ arg.app (arg.var op) a; '1 ∝ nil; 〉
                    )
            ;
        . expr.function.w env (expr.app e (p #0)) (p #1)
    )
|]

$gsdeclare lambda-like-keyword gslambda_like_keyword

$gsdeclare generators gsgenerators
$gsdeclare pat gspat

gsexpr_lambda_like = [gs:value| λ 'env. parser.for
        'v ← lambda-like-keyword env;
        's ← parser.unit $ parser.env.signature.get v env;
        'es ← many $ explicit-arg env;
        'ves ← parser.unit $ foldl expr.app (expr.var v) $ map (λ 'p. arg.explicit (p #0) (p #1)) es;
        'posh ← get-pos;
        'h ← analyze s.
            case order-of-being.generator : _. parser.map (λ 'p. expr.generators (p #0) (p #1)) (generators env)
            case order-of-being.pattern : _. parser.map (λ 'p. expr.pat p nothing) (pat env)
            case nil. parser.for 'p ← expr env;. parser.unit (p #0)
        ;
        _ ← lexeme (char r{.});
        'post ← get-pos;
        't ←
            <|> (analyze parser.env.missing-body.get v env.
                case nothing. empty
                case just 'me. parser.unit me
            )
            <|> (analyze drop 1 s.
                case order-of-being.open-expr : _. parser.for 'p ← expr env;. parser.unit (expr.open-expr (p #0) nothing)
                case nil. parser.for 'p ← expr env;. parser.unit (p #0)
            )
        ;
    . analyze parser.env.else.get v env.
        case nothing. parser.unit 〈 '0 ∝ foldl expr.app ves (arg.expr posh h : arg.expr post t : nil); '1 ∝ drop 2 s; 〉
        case just _. parser.for
                _ ← analyze parser.env.else-needs-comma.get env.
                    case true. lexeme (char r{,})
                    case false. parser.unit 〈〉
                ;
                'pose ← get-pos;
                'e ←
                    <|> (analyze parser.env.missing-else.get v env.
                        case nothing. empty
                        case just 'me. parser.unit me
                    )
                    <|> (analyze drop 2 s.
                        case nil. parser.for 'p ← expr env;. parser.unit (p #0)
                    )
                ;
            . parser.unit 〈 '0 ∝ foldl expr.app ves (arg.expr posh h : arg.expr post t : arg.expr pose e : nil); '1 ∝ drop 3 s; 〉
|]

$gsdeclare parens parens
$gsdeclare natural natural

$gsdeclare var var
$gsdeclare idmc gsidmc
$gsdeclare qloitem gsqloitem

gsexpr_atom = [gs:value| λ 'a. λ 'env.
    <|> parens (expr env)
    <|> (parser.for
            _ ← lexeme $ char r{〈};
            'p ← generators env;
            _ ← lexeme $ char r{〉};
        . parser.unit 〈 '0 ∝ expr.structure-literal (p #0) (p #1); '1 ∝ nil; 〉
    )
    <|> (parser.for
            'v ← parser.map gsvar ident-chars;
            _ ← char r{\{};
            'e ← analyze parser.env.qlo.get v env.
                case nothing. parser.fail log{§(log.str (gsvar.fmt-atom v)) is not a qlo}
                case just 'e. parser.unit e
            ;
            'x ← idmc env (e #parse) r{\}};
            _ ← lexeme $ char r{\}};
        . parser.unit 〈 '0 ∝ expr.qlo v e x; '1 ∝ nil; 〉
    )
    <|> (parser.for 'n ← natural;. parser.unit 〈 '0 ∝ expr.natural n; '1 ∝ nil; 〉)
    <|> (parser.for
            'v ← var env;
            'es ← analyze a.
                case true. many $ explicit-arg env
                case false. parser.unit nil
            ;
            'ves ← parser.unit $ foldl expr.app (expr.var v) $ map (λ 'p. arg.explicit (p #0) (p #1)) es;
        . parser.unit 〈
            '0 ∝ ves;
            '1 ∝ parser.env.signature.get v env;
        〉
    )
|]

gsexplicit_arg = [gs:value| λ 'env. parser.for
        _ ← matching log{explicit application character} (rune.≡ r{_});
        'pose ← get-pos;
        'e ← parser.map expr.var (var env);
    . parser.unit 〈 '0 ∝ pose; '1 ∝ e; 〉
|]

$gsdeclare idmc-w gsidmc_w

gsidmc = [gs:value| λ 'env. λ 'p. λ 'cl. idmc-w env (parser-run (p env)) cl |]

gsidmc_w = [gs:value| λ 'env. λ 'p. λ 'cl. analyze p.
    case parser.prim.unit-plus 'x 'p1. parser.unit x <|> idmc-w env p1 cl
    case parser.prim.symbol-or-eof 'ek 'sk.
        <|> (parser.eof *> idmc-w env ek cl)
        <|> (parser.for 'q ← qloitem env cl;. analyze sk q.
            case right 'p1. idmc-w env p1 cl
        )
|]

gsqloitem = [gs:value| λ 'env. λ 'cl.
    <|> (parser.for 'r ← matching log{normal character} (λ 'r. list.∉ rune.≡ r qq{\§\\(){}[]} && rune.≠ r cl);. parser.unit (qloitem.char r))
|]

$gsdeclare pat.function gspat_function

gsgenerators = [gs:value| λ 'env. parser.for
        'gs ← many $ parser.for
                'pos ← get-pos;
                'g ← generator env;
                _ ← lexeme (char r{;});
            . parser.unit 〈 'pos ∝ pos; 'gen ∝ g; 'bvs ∝ nothing; 〉
        ;
        'pos1 ← get-pos;
    . parser.unit 〈 '0 ∝ gs; '1 ∝ pos1; 〉
|]

gsgenerator = [gs:value| λ 'env.
    <|> (parser.for
            'pos0 ← get-pos;
            'p0 ← parser.choice $
                map (λ 'o. parser.for
                        'x0 ← analyze o.
                            case order-of-being.pattern. parser.for 'p ← pat.function env;. parser.unit $ generator.pattern p nothing
                        ;
                    . parser.unit 〈 '0 ∝ o; '1 ∝ x0; 〉
                ) $
                ordered-set.to-list $
                foldr
                    (λ 'sig. λ 's. analyze sig.
                        case 'o : _. ordered-set.insert order-of-being.<=> o s
                    )
                    ordered-set.empty
                    $
                parser.env.signatures.get $
                parser.env.generator.get $
                env
            ;
            'op ← operator env;
            's1 ← analyze parser.env.signature.get op (parser.env.generator.get env).
                case 'o : 's1. (analyze order-of-being.≡ o (p0 #0).
                    case true. parser.unit s1
                )
            ;
            'pos1 ← get-pos;
            'g1 ← analyze s1.
                case order-of-being.expr : _. parser.map generator.expr $ parser.map (λ 'p. p #0) $ expr.function env
            ;
        . parser.unit (generator.app (generator.app (generator.var op) pos0 (p0 #1)) pos1 g1)
    )
|]

gspat = [gs:value| λ 'env.
    <|> (parser.for 'pos0 ← get-pos; 'p0 ← pat.function env;.
        <|> parser.unit p0
        <|> parser.for
                'posop ← get-pos;
                'op ← operator env;
                'pos1 ← get-pos;
                'p1 ← pat.function env;
            . parser.unit (pat.app (pat.app (pat.view op) pos0 p0) pos1 p1)
    )
|]

$gsdeclare pat.function-w gspat_function_w

gspat_function = [gs:value| λ 'env. parser.for 'p ← pat.atom env;. pat.function-w env p |]

gspat_function_w = [gs:value| λ 'env. λ 'p.
    <|> parser.unit p
    <|> parser.for 'pos ← get-pos; 'p1 ← pat.atom env;. pat.function-w env (pat.app p pos p1)
|]

gspat_atom = [gs:value| λ 'env.
    <|> (parser.for _ ← lexeme (char r{_});. parser.unit pat.discard)
    <|> (parser.for 'v ← var env;. parser.unit (pat.view v))
    <|> (parser.for 'v ← char r{'} *> ident;. parser.unit (pat.var v))
|]

parens = [gs:value| λ 'p. lexeme (matching log{open parenthesis} (rune.≡ r{\(})) *> p <* lexeme (matching log{close parenthesis} (rune.≡ r{\)})) |]

var = [gs:value| λ 'env. lexeme $ parser.for
        'v ← parser.map gsvar ident-chars;
        _ ← not-followed-by (char r{\{} <|> char r{<} <|> char r{/});
        _ ← analyze parser.env.syntactic-category.get v env.
            case syntactic-category.variable. parser.unit 〈〉
            case syntactic-category.lambda-like. parser.fail log{'§(log.str (gsvar.fmt-atom v))' is lambda-like}
        ;
    . parser.unit v
|]

gslambda_like_keyword = [gs:value| λ 'env. lexeme $ parser.for
        'v ← parser.map gsvar ident-chars;
        _ ← not-followed-by (char r{\{} <|> char r{<} <|> char r{/});
        _ ← analyze parser.env.syntactic-category.get v env.
            case syntactic-category.variable. parser.fail log{'§(log.str (gsvar.fmt-atom v))' is a variable}
            case syntactic-category.lambda-like. parser.unit 〈〉
        ;
    . parser.unit v
|]

where_keyword = [gs:value| λ 'env. lexeme $ parser.for
        'v ← parser.map gsvar ident-chars;
        _ ← not-followed-by (char r{\{} <|> char r{<} <|> char r{/});
        _ ← analyze parser.env.syntactic-category.get v env.
        ;
    . parser.unit v
|]

colon_paren = [gs:value| λ 'env. lexeme $ parser.for
        'v ← parser.map gsvar (string qq{:});
        -- No need for negative look-ahead since there is a mandatory following space
        _ ← matching log{whitespace} is-space;
    . parser.unit v
|]

ident = [gs:value| lexeme $ parser.map gsvar ident-chars |]

operator = [gs:value| λ 'env. lexeme $ parser.for
        'o ← parser.map gsvar op-chars;
        _ ← analyze parser.env.syntactic-category.get o env.
            case syntactic-category.variable. parser.unit 〈〉
            case syntactic-category.arg-operator. parser.fail log{'§(log.str (gsvar.fmt-atom o))' is a prefix operator}
        ;
    . parser.unit o
|]

arg_operator = [gs:value| λ 'env. lexeme $ parser.for
        'o ← parser.map gsvar op-chars;
        _ ← analyze parser.env.syntactic-category.get o env.
            case syntactic-category.variable. parser.fail log{'§(log.str (gsvar.fmt-atom o))' is a regular operator}
            case syntactic-category.arg-operator. parser.unit 〈〉
        ;
    . parser.unit o
|]

$gsdeclare delimiter delimiter

$gsdeclare op-component op_component

op_chars = [gs:value| op-component <* not-followed-by delimiter |]

$gsdeclare ident-component ident_component
$gsdeclare cont-component cont_component
$gsdeclare concat gsconcat

ident_chars = [gs:value|
    parser.map2 (<>) ident-component (parser.map concat (max-many cont-component))
|]

gsconcat = [gs:value| foldr (<>) nil |]

cont_component = [gs:value| parser.map2 (:) delimiter ident-component |]

$gsdeclare ident-start-char ident_start_char
$gsdeclare ident-comp-cont ident_comp_cont

ident_component = [gs:value| parser.map2 (:) ident-start-char ident-comp-cont |]

$gsdeclare ident-cont-char ident_cont_char
$gsdeclare ident-up-cont-char ident_up_cont_char
$gsdeclare ident-comp-up-cont ident_comp_up_cont

ident_comp_cont = [gs:value|
    <|> (not-followed-by (ident-cont-char <|> ident-up-cont-char) *> parser.unit nil)
    <|> parser.map2 (:) ident-cont-char ident-comp-cont
    <|> parser.map2 (:) ident-up-cont-char ident-comp-up-cont
|]

ident_comp_up_cont = [gs:value|
    <|> (not-followed-by (ident-cont-char <|> ident-up-cont-char) *> parser.unit nil)
    <|> parser.map2 (:) ident-up-cont-char ident-comp-up-cont
|]

$gsdeclare op-start-char op_start_char
$gsdeclare op-cont-char op_cont_char

op_component = [gs:value| parser.map2 (:) op-start-char (max-many op-cont-char) |]

delimiter = [gs:value| matching log{delimiter} (λ 'c. rune.≡ c r{-} || rune.≡ c r{.}) |]

ident_start_char = [gs:value| matching log{ident start character} is-lower |]
ident_cont_char = [gs:value| matching log{ident cont character} is-lower |]
ident_up_cont_char = [gs:value| matching log{ident cont character} (λ 'c. is-upper c || is-ascii-digit c) |]

op_start_char = [gs:value| matching log{op start character} (λ 'c. list.∈ rune.≡ c qq{~!@#$%^&*:-+=|\\<>?/∘} || is-non-ascii-symbol c) |]
op_cont_char = [gs:value| matching log{op cont character} (λ 'c. list.∈ rune.≡ c qq{~!@#$%^&*:-+=|\\<>?/∘}) |]

natural = [gs:value| lexeme $ parser.map natural.read-decimal $ many1 $ matching log{digit} is-ascii-digit |]

lexeme = [gs:value| λ 'p. p <* whitespace |]

whitespace = [gs:value| many (
    <|> matching log{whitespace} is-space
    <|> (
        *> string qq{--}
        *> not-followed-by op-cont-char
        *> many (matching log{non-newline} (rune.≠ r{\n}))
        *> matching log{newline} (rune.≡ r{\n})
    )
) |]
