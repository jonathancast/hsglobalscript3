{-# LANGUAGE TemplateHaskell #-}
module GSDL.Syntax (file, pragmas, pragmawhitespace, interpolation, quote, ident, lexeme, whitespace) where

$gsimports

$gsdeclare document document

file = [gs:value| λ 'env.
    <|> parser.for
            _ ← pragmas;
            'pos ← get-pos;
            'd ← whitespace *> document env;
        . parser.unit (file.document pos d)
|]

pragmas = [gs:value| pragma.whitespace *> many empty |]

pragmawhitespace = [gs:value| many (
    <|> (
        *> string qq{#!}
        *> many (matching log{comment body character} (λ 'c. c ≠ r{\n}))
        *> char r{\n}
        *> parser.unit 〈〉
    )
    <|> (
        *> string qq{\n}
        *> parser.unit 〈〉
    )
) |]

$gsdeclare where-keyword where_keyword
$gsdeclare colon-paren colon_paren

$gsdeclare generator gsgenerator

document = [gs:value| λ 'env. parser.for
        'mbe ← optional (parser.for 'p ← expr env;. parser.unit (p #0));
        'mbw ← optional (
            *> lexeme (char r{,})
            *> where-keyword env
            *> colon-paren
            *> (generator env <* lexeme (char r{;}))
        );
    . parser.unit (document.in mbe mbw)
|]

$gsdeclare keyword keyword
$gsdeclare hsident hsident

interpolation = [gs:value| λ 'env.
    <|> (keyword qq{gsimports} *> parser.unit source-comp.imports)
|]

$gsdeclare quote-param quote_param

$gsdeclare keyword-op keyword_op

quote = [gs:value| λ 'env. λ 'pos0.
    <|> (parser.for
            _ ← keyword qq{value};
            'ps ← many $ quote-param env;
            _ ← keyword-op qq{|};
            'pos1 ← get-pos;
            'e ← expr env;
        . parser.unit (source-comp.value pos0 ps pos1 (e #0))
    )
    <|> (parser.for
            _ ← keyword qq{expr};
            'ps ← many $ quote-param env;
            _ ← keyword-op qq{|};
            'pos1 ← get-pos;
            'e ← expr env;
        . parser.unit (source-comp.expr ps pos1 (e #0))
    )
|]

quote_param = [gs:value| λ 'env.
    <|> (parser.for
            _ ← keyword qq{hsvs};
            _ ← keyword-op qq{=};
            'vs ← many (ident env <* lexeme (char r{,}));
        . parser.unit $ quote-param.hsvs vs
    )
|]

$gsdeclare operator operator

$gsdeclare explicit-arg gsexplicit_arg

$gsdeclare expr.function gsexpr_function
$gsdeclare expr.lambda-like gsexpr_lambda_like

expr = [gs:value| λ 'env.
    <|> (parser.for 'pos0 ← get-pos; 'p0 ← expr.function env;.
        <|> parser.unit p0
        <|> parser.for
                'posop ← get-pos;
                'op ← operator env;
                's1 ← analyze parser.env.signature.get op env.
                    case nothing. parser.unit nil
                ;
                'es ← many $ explicit-arg env;
                'opes ← parser.unit $ foldl expr.app (expr.var op) $ map (λ 'p. arg.explicit (p #0) (p #1)) es;
                'pos1 ← get-pos;
                'p1 ← expr.function env <|> expr.lambda-like env;
                's2 ← analyze s1.
                    case nil. parser.unit nil
                ;
            . parser.unit 〈 '0 ∝ expr.app (expr.app opes (arg.expr pos0 (p0 #0))) (arg.expr pos1 (p1 #0)); '1 ∝ s2; 〉
    )
    <|> expr.lambda-like env
|]

$gsdeclare expr.function.w gsexpr_function_w

gsexpr_function = [gs:value| λ 'env. parser.for 'p ← expr.atom true env;. expr.function.w env (p #0) (p #1) |]

$gsdeclare pat gspat

gsexpr_function_w = [gs:value| λ 'env. λ 'e. λ 's.
    <|> parser.unit 〈 '0 ∝ e; '1 ∝ s; 〉
    <|> (parser.for
            'pos ← get-pos;
            'p ← analyze s.
                case order-of-being.pattern : 's1. parser.for 'p ← pat env;. parser.unit 〈 '0 ∝ expr.pat p nothing; '1 ∝ s1; 〉
                case nil. parser.for 'p ← expr.atom false env;. parser.unit 〈 '0 ∝ p #0; '1 ∝ nil; 〉
            ;
        . expr.function.w env (expr.app e (arg.expr pos (p #0))) (p #1)
    )
|]

$gsdeclare lambda-like-keyword gslambda_like_keyword

gsexpr_lambda_like = [gs:value| λ 'env. parser.for
        'v ← lambda-like-keyword env;
        's ← parser.unit $ analyze parser.env.signature.get v env. case nothing. nil case just 's. s;
        'es ← many $ explicit-arg env;
        'ves ← parser.unit $ foldl expr.app (expr.var v) $ map (λ 'p. arg.explicit (p #0) (p #1)) es;
        'posh ← get-pos;
        'h ← analyze s.
            case order-of-being.pattern : _. parser.map (λ 'p. expr.pat p nothing) (pat env)
            case nil. parser.for 'p ← expr env;. parser.unit (p #0)
        ;
        _ ← lexeme (char r{.});
        'post ← get-pos;
        't ←
            <|> (analyze parser.env.missing-body.get v env.
                case nothing. empty
                case just 'me. parser.unit me
            )
            <|> (analyze drop 1 s.
                case order-of-being.open-expr : _. parser.for 'p ← expr env;. parser.unit (expr.open-expr (p #0) nothing)
                case nil. parser.for 'p ← expr env;. parser.unit (p #0)
            )
        ;
    . analyze parser.env.else.get v env.
        case nothing. parser.unit 〈 '0 ∝ foldl expr.app ves (arg.expr posh h : arg.expr post t : nil); '1 ∝ drop 2 s; 〉
        case just _. parser.for
                _ ← lexeme (char r{,});
                'pose ← get-pos;
                'e ←
                    <|> (analyze parser.env.missing-else.get v env.
                        case nothing. empty
                        case just 'me. parser.unit me
                    )
                    <|> (analyze drop 2 s.
                        case nil. parser.for 'p ← expr env;. parser.unit (p #0)
                    )
                ;
            . parser.unit 〈 '0 ∝ foldl expr.app ves (arg.expr posh h : arg.expr post t : arg.expr pose e : nil); '1 ∝ drop 3 s; 〉
|]

$gsdeclare parens parens
$gsdeclare natural natural

$gsdeclare ident-chars ident_chars

$gsdeclare idmc gsidmc
$gsdeclare qloitem gsqloitem

gsexpr_atom = [gs:value| λ 'a. λ 'env.
    <|> parens (expr env)
    <|> (parser.for
            _ ← lexeme $ char r{〈};
            'gs ← many (generator env <* lexeme (char r{;}));
            _ ← lexeme $ char r{〉};
        . parser.unit 〈 '0 ∝ expr.structure-literal gs; '1 ∝ nil; 〉
    )
    <|> (parser.for
            'v ← ident-chars;
            'e ← analyze parser.env.qlo.get (gsvar v) env.
                case nothing. parser.fail log{§(gsv v) is not a qlo}
                case just 'e. parser.unit e
            ;
            _ ← char r{\{};
            'x ← idmc env (e #parse) r{\}};
            _ ← lexeme $ char r{\}};
        . parser.unit 〈 '0 ∝ expr.qlo (gsvar v) e x; '1 ∝ nil; 〉
    )
    <|> (parser.for 'n ← natural;. parser.unit 〈 '0 ∝ expr.natural n; '1 ∝ nil; 〉)
    <|> (parser.for
            'v ← ident env;
            'es ← analyze a.
                case true. many $ explicit-arg env
                case false. parser.unit nil
            ;
            'ves ← parser.unit $ foldl expr.app (expr.var v) $ map (λ 'p. arg.explicit (p #0) (p #1)) es;
        . parser.unit 〈
            '0 ∝ ves;
            '1 ∝ analyze parser.env.signature.get v env. case nothing. nil case just 's. s;
        〉
    )
|]

gsexplicit_arg = [gs:value| λ 'env. parser.for
        _ ← matching log{explicit application character} (rune.≡ r{_});
        'pose ← get-pos;
        'e ← parser.map expr.var (ident env);
    . parser.unit 〈 '0 ∝ pose; '1 ∝ e; 〉
|]

$gsdeclare idmc-w gsidmc_w

gsidmc = [gs:value| λ 'env. λ 'p. λ 'cl. idmc-w env (parser-run (p env)) cl |]

gsidmc_w = [gs:value| λ 'env. λ 'p. λ 'cl. analyze p.
    case parser.prim.unit-plus 'x 'p1. parser.unit x <|> idmc-w env p1 cl
    case parser.prim.symbol-or-eof 'ek 'sk.
        <|> (parser.eof *> idmc-w env ek cl)
        <|> (parser.for 'q ← qloitem env cl;. analyze sk q.
            case right 'p1. idmc-w env p1 cl
        )
|]

gsqloitem = [gs:value| λ 'env. λ 'cl.
    <|> (parser.for 'r ← matching log{normal character} (λ 'r. list.∉ rune.≡ r qq{\§\\(){}[]} && rune.≠ r cl);. parser.unit (qloitem.char r))
|]

gsgenerator = [gs:value| λ 'env.
    parser.fail log{generator next}
|]

$gsdeclare pat.function gspat_function

gspat = [gs:value| λ 'env.
    <|> pat.function env
|]

$gsdeclare pat.atom gspat_atom
$gsdeclare pat.function-w gspat_function_w

gspat_function = [gs:value| λ 'env. parser.for 'p ← pat.atom env;. pat.function-w env p |]

gspat_function_w = [gs:value| λ 'env. λ 'p.
    <|> parser.unit p
    <|> parser.for 'pos ← get-pos; 'p1 ← pat.atom env;. pat.function-w env (pat.app p pos p1)
|]

$gsdeclare pident pident

gspat_atom = [gs:value| λ 'env.
    <|> (parser.for _ ← lexeme (char r{_});. parser.unit pat.discard)
    <|> (parser.for 'v ← ident env;. parser.unit (pat.view v))
    <|> (parser.for 'v ← char r{'} *> pident;. parser.unit (pat.var v))
|]

parens = [gs:value| λ 'p. lexeme (matching log{open parenthesis} (rune.≡ r{\(})) *> p <* lexeme (matching log{close parenthesis} (rune.≡ r{\)})) |]

keyword = [gs:value| λ 'kw. lexeme $ parser.for 's ← ident-chars;. analyze list.≡ rune.≡ s kw.
    case false. parser.fail log{'§(log.str s)' is not '§(log.str kw)'}
    case true. parser.unit 〈〉
|]

ident = [gs:value| λ 'env. lexeme $ parser.for
        'v ← parser.map gsvar ident-chars;
        _ ← not-followed-by (char r{\{} <|> char r{<} <|> char r{/});
        _ ← analyze parser.env.syntactic-category.get v env.
            case syntactic-category.variable. parser.unit 〈〉
            case syntactic-category.lambda-like. parser.fail log{'§(undefined)' is lambda-like}
        ;
    . parser.unit v
|]

gslambda_like_keyword = [gs:value| λ 'env. lexeme $ parser.for
        'v ← parser.map gsvar ident-chars;
        _ ← not-followed-by (char r{\{} <|> char r{<} <|> char r{/});
        _ ← analyze parser.env.syntactic-category.get v env.
            case syntactic-category.variable. parser.fail log{'§(log.dstr (gsvar.fmt-atom v))' is a variable}
            case syntactic-category.lambda-like. parser.unit 〈〉
        ;
    . parser.unit v
|]

where_keyword = [gs:value| λ 'env. lexeme $ parser.for
        'v ← parser.map gsvar ident-chars;
        _ ← not-followed-by (char r{\{} <|> char r{<} <|> char r{/});
        _ ← analyze parser.env.syntactic-category.get v env.
        ;
    . parser.unit v
|]

colon_paren = [gs:value| λ 'env. lexeme $ parser.for
        'v ← parser.map gsvar (string qq{:});
        -- No need for negative look-ahead since there is a mandatory following space
        _ ← matching log{whitespace} is-space;
    . parser.unit v
|]

pident = [gs:value| lexeme $ parser.map gsvar ident-chars |]

$gsdeclare ident-start-char identStartChar
$gsdeclare ident-cont-char identContChar

$gsdeclare op-chars op_chars

operator = [gs:value| λ 'env. lexeme $ parser.for
        'o ← parser.map gsvar op-chars;
        _ ← analyze parser.env.syntactic-category.get o env.
            case syntactic-category.variable. parser.unit 〈〉
        ;
    . parser.unit o
|]

keyword_op = [gs:value| λ 'kw. lexeme $ parser.for 's ← op-chars;. analyze list.≡ rune.≡ s kw.
    case true. parser.unit 〈〉
|]

$gsdeclare delimiter delimiter

$gsdeclare op-component op_component
$gsdeclare op-cont-char opContChar

op_chars = [gs:value| op-component <* not-followed-by delimiter |]

$gsdeclare max-many gsmax_many

$gsdeclare ident-component ident_component
$gsdeclare cont-component cont_component
$gsdeclare concat gsconcat

ident_chars = [gs:value|
    parser.map2 (<>) ident-component (parser.map concat (max-many cont-component))
|]

$gsdeclare hsident-start-char hsident_start_char
$gsdeclare hsident-comp-char hsident_comp_char

hsident = [gs:value| parser.map2 (:) hsident-start-char (max-many hsident-comp-char) |]

hsident_start_char = [gs:value| matching log{HS ident start char} is-lower |]
hsident_comp_char = [gs:value| matching log{HS ident cont char} (λ 'c. is-letter c || is-ascii-digit c || rune.≡ c r{_}) |]

gsconcat = [gs:value| foldr (<>) nil |]

cont_component = [gs:value| parser.map2 (:) delimiter ident-component |]

$gsdeclare ident-comp-cont ident_comp_cont

ident_component = [gs:value| parser.map2 (:) ident-start-char ident-comp-cont |]

$gsdeclare ident-comp-up-cont ident_comp_up_cont

$gsdeclare ident-up-cont-char ident_up_cont_char

ident_comp_cont = [gs:value|
    <|> (not-followed-by (ident-cont-char <|> ident-up-cont-char) *> parser.unit nil)
    <|> parser.map2 (:) ident-cont-char ident-comp-cont
    <|> parser.map2 (:) ident-up-cont-char ident-comp-up-cont
|]

ident_comp_up_cont = [gs:value|
    <|> (not-followed-by (ident-cont-char <|> ident-up-cont-char) *> parser.unit nil)
    <|> parser.map2 (:) ident-up-cont-char ident-comp-up-cont
|]

$gsdeclare op-start-char op_start_char

op_component = [gs:value| parser.map2 (:) op-start-char (max-many op-cont-char) |]

delimiter = [gs:value| matching log{delimiter} (λ 'c. rune.≡ c r{-} || rune.≡ c r{.}) |]

identStartChar = [gs:value| matching log{ident start character} is-lower |]
identContChar = [gs:value| matching log{ident cont character} is-lower |]
ident_up_cont_char = [gs:value| matching log{ident cont character} (λ 'c. is-upper c || is-ascii-digit c) |]

op_start_char = [gs:value| matching log{op start character} (λ 'c. list.∈ rune.≡ c qq{~!@#$%^&*-+=|\\<>?/∘}) |]
opContChar = [gs:value| matching log{op cont character} (λ 'c. list.∈ rune.≡ c qq{~!@#$%^&*-+=|\\<>?/∘}) |]

natural = [gs:value| lexeme $ parser.map natural.read-decimal $ many1 $ matching log{digit} is-ascii-digit |]

lexeme = [gs:value| λ 'p. p <* whitespace |]

gsmax_many = [gs:value| λ 'p. many p <* not-followed-by p |]

whitespace = [gs:value| many (
    <|> matching log{whitespace} is-space
    <|> (
        *> string qq{--}
        *> not-followed-by op-cont-char
        *> many (matching log{non-newline} (rune.≠ r{\n}))
        *> matching log{newline} (rune.≡ r{\n})
    )
) |]
