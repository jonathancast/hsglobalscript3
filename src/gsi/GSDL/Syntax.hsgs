{-# LANGUAGE TemplateHaskell #-}
module GSDL.Syntax (file, pragmas, pragmawhitespace, ident, lexeme, whitespace) where

$gsimports

file = [gs:value| λ 'env.
    <|> parser.for
            _ ← pragmas;
            'pos ← get-pos;
            'mb ← whitespace *> optional (parser.for 'p ← expr env;. parser.unit (p #0));
        . parser.unit (file.document pos mb)
|]

pragmas = [gs:value| pragma.whitespace *> many empty |]

pragmawhitespace = [gs:value| many (
    <|> (
        *> string qq{#!}
        *> many (matching log{comment body character} (λ 'c. c ≠ r{\n}))
        *> char r{\n}
        *> parser.unit 〈〉
    )
    <|> (
        *> string qq{\n}
        *> parser.unit 〈〉
    )
) |]

$gsdeclare expr.function gsexpr_function
$gsdeclare expr.lambda-like gsexpr_lambda_like

expr = [gs:value| λ 'env.
    <|> expr.function env
    <|> expr.lambda-like env
|]

$gsdeclare expr.function.w gsexpr_function_w

gsexpr_function = [gs:value| λ 'env. parser.for 'p ← expr.atom env;. expr.function.w env (p #0) (p #1) |]

$gsdeclare pat gspat

gsexpr_function_w = [gs:value| λ 'env. λ 'e. λ 's.
    <|> parser.unit 〈 '0 ∝ e; '1 ∝ s; 〉
    <|> (parser.for
            'pos ← get-pos;
            'p ← analyze s.
                case order-of-being.pattern : 's1. parser.for 'p ← pat env;. parser.unit 〈 '0 ∝ expr.pat p nothing; '1 ∝ s1; 〉
                case nil. parser.for 'p ← expr.atom env;. parser.unit 〈 '0 ∝ p #0; '1 ∝ nil; 〉
            ;
        . expr.function.w env (expr.app e (arg.expr pos (p #0))) (p #1)
    )
|]

$gsdeclare keyword keyword

gsexpr_lambda_like = [gs:value| λ 'env. parser.for
        'v ← parser.choice $ map (λ 'p. keyword (gsvar.name (p #0)) *> parser.unit (p #0)) $ parser.env.lambda-likes env;
        's ← parser.unit $ analyze parser.env.signature.get v env. case nothing. nil case just 's. s;
        'posh ← get-pos;
        'h ← analyze s.
            case order-of-being.pattern : _. parser.map (λ 'p. expr.pat p nothing) (pat env)
            case nil. parser.for 'p ← expr env;. parser.unit (p #0)
        ;
        _ ← lexeme (char r{.});
        'post ← get-pos;
        't ←
            <|> (analyze parser.env.missing-body.get v env.
                case nothing. empty
                case just 'me. parser.unit me
            )
            <|> (analyze drop 1 s.
                case order-of-being.open-expr : _. parser.for 'p ← expr env;. parser.unit (expr.open-expr (p #0) nothing)
                case nil. parser.for 'p ← expr env;. parser.unit (p #0)
            )
        ;
    . analyze parser.env.else.get v env.
        case nothing. parser.unit 〈 '0 ∝ foldl expr.app (expr.var v) (arg.expr posh h : arg.expr post t : nil); '1 ∝ drop 2 s; 〉
        case just _. parser.for
                _ ← lexeme (char r{,});
                'pose ← get-pos;
                'e ←
                    <|> (analyze parser.env.missing-else.get v env.
                        case nothing. empty
                    )
                    <|> (analyze drop 2 s.
                        case nil. parser.for 'p ← expr env;. parser.unit (p #0)
                    )
                ;
            . parser.unit 〈 '0 ∝ foldl expr.app (expr.var v) (arg.expr posh h : arg.expr post t : arg.expr pose e : nil); '1 ∝ drop 3 s; 〉
|]

$gsdeclare parens parens
$gsdeclare natural natural

gsexpr_atom = [gs:value| λ 'env.
    <|> parens (expr env)
    <|> (parser.for 'n ← natural;. parser.unit 〈 '0 ∝ expr.natural n; '1 ∝ nil; 〉)
    <|> (parser.for 'v ← ident env;. parser.unit 〈
        '0 ∝ expr.var v;
        '1 ∝ analyze parser.env.signature.get v env. case nothing. nil case just 's. s;
    〉)
|]

$gsdeclare pident pident

gspat = [gs:value| λ 'env.
    <|> (parser.for 'v ← ident env;. parser.unit (pat.view v))
    <|> (parser.for 'v ← char r{'} *> pident;. parser.unit (pat.var v))
|]

parens = [gs:value| λ 'p. lexeme (matching log{open parenthesis} (rune.≡ r{\(})) *> p <* lexeme (matching log{close parenthesis} (rune.≡ r{\)})) |]

$gsdeclare ident-chars ident_chars

ident = [gs:value| λ 'env. lexeme $ parser.for
        'v ← parser.map gsvar ident-chars;
        _ ← analyze parser.env.lambda-like.get v env.
            case nothing. parser.unit 〈〉
            case just _. parser.fail log{'§(undefined)' is lambda-like}
        ;
    . parser.unit v
|]

pident = [gs:value| lexeme $ parser.map gsvar ident-chars |]

$gsdeclare ident-start-char identStartChar
$gsdeclare ident-cont-char identContChar

keyword = [gs:value| λ 's. lexeme (string s <* not-followed-by ident-cont-char) |]

$gsdeclare max-many gsmax_many

$gsdeclare ident-component ident_component
$gsdeclare cont-component cont_component
$gsdeclare delimiter delimiter
$gsdeclare concat gsconcat

ident_chars = [gs:value|
    parser.map2 (<>) ident-component (parser.map concat (max-many cont-component))
|]

gsconcat = [gs:value| foldr (<>) nil |]

cont_component = [gs:value| parser.map2 (:) delimiter ident-component |]

ident_component = [gs:value| parser.map2 (:) ident-start-char (max-many ident-cont-char) |]

delimiter = [gs:value| matching log{delimiter} (λ 'c. rune.≡ c r{-} || rune.≡ c r{.}) |]

identStartChar = [gs:value| matching log{ident start character} is-lower |]
identContChar = [gs:value| matching log{ident cont character} is-lower |]

opContChar = [gs:value| matching log{op cont character} (rune.≡ r{-}) |]

natural = [gs:value| lexeme $ parser.map natural.read-decimal $ many1 $ matching log{digit} is-ascii-digit |]

lexeme = [gs:value| λ 'p. p <* whitespace |]

$gsdeclare op-cont-char opContChar

gsmax_many = [gs:value| λ 'p. many p <* not-followed-by p |]

whitespace = [gs:value| many (
    <|> matching log{whitespace} is-space
    <|> (
        *> string qq{--}
        *> not-followed-by op-cont-char
        *> many (matching log{non-newline} (rune.≠ r{\n}))
        *> matching log{newline} (rune.≡ r{\n})
    )
) |]
