module GSDL.Annotate (gsannotate_document) where

$gsimports

$gsdeclare annotate-expr gsannotate_expr

gsannotate_document = [gs:value| λ 'env. λ 'pos. λ 'mbe. analyze mbe.
    case nothing. nothing
    case just 'e. just (annotate-expr env pos e nothing)
|]

$gsdeclare annotate-pat gsannotate_pat

$gsdeclare annotate-app gsannotate_app

gsannotate_expr = [gs:value| λ 'env. λ 'pos. λ 'e. λ 'ns. analyze e.
    case expr.var 'v. expr.var v
    case expr.natural 'n. expr.natural n
    case expr.pat 'p 'mb. (analyze mb.
        case nothing. (analyze ns.
            case nothing. expr.pat (annotate-pat env pos p) (just (pat.bound-vars p))
            case just 'bvs. expr.pat (annotate-pat env pos p) (just bvs)
        )
    )
    case expr.open-expr 'e1 'mb. (analyze mb.
        case nothing. (analyze ns.
            case nothing. expr.open-expr (annotate-expr env pos e1 ns) (just nil)
            case just 'bvs. expr.open-expr (annotate-expr env pos e1 ns) (just bvs)
        )
        case just 'bvs. expr.open-expr (annotate-expr env pos e1 ns) (just bvs)
    )
    case expr.app 'f 'x. annotate-app env pos f (x:nil)
    case expr.missing-case. expr.missing-case
|]

$gsdeclare let gslet


$gsdeclare annotate-arg gsannotate_arg

gsannotate_app = [gs:value| λ 'env. λ 'pos. λ 'f. λ 'as. analyze f.
    case expr.var 'v. (analyze annotator.env.namespace.get v env.
        case nothing. foldl expr.app (expr.var v) (map (λ 'a. annotate-arg env pos a nothing) as)
        case just 'ns-decl. let (zip as (ns-decl as <> repeat nothing)) $ λ 'eas.
            foldl expr.app (expr.var v) (map (λ 'p. annotate-arg env pos (p #0) (p #1)) eas)
    )
    case expr.app 'f1 'x. annotate-app env pos f1 (x:as)
|]

gsannotate_arg = [gs:value| λ 'env. λ 'pos. λ 'a. λ 'ns. analyze a.
    case arg.expr 'pos1 'e. arg.expr pos1 (annotate-expr env pos1 e ns)
|]

gsannotate_pat = [gs:value| λ 'env. λ 'pos. λ 'p. analyze p.
    case pat.var 'v. pat.var v
    case pat.view 'v. pat.view v
|]

gslet = [gs:value| λ 'e. λ 'k. k e |]
