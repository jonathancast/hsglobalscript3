{-# LANGUAGE TemplateHaskell #-}
module GSDL.HSGS.AST (
    gssource_comp_char, gssource_comp_pos, gssource_comp_imports, gssource_comp_declare, gssource_comp_value, gssource_comp_expr, gssource_comp_char_view, gssource_comp_pos_view, gssource_comp_imports_view, gssource_comp_declare_view, gssource_comp_value_view, gssource_comp_expr_view,
    gsquote_param_hsvs, gsquote_param_hsvs_view,
    gsdest_comp_char, gsdest_comp_pos, gsdest_comp_imports, gsdest_comp_expr, gsdest_comp_char_view, gsdest_comp_pos_view, gsdest_comp_imports_view, gsdest_comp_expr_view,
    gshsimport_fmt, gshsimport_cmp, gshsimport_var, gshsimport_type,
    gshsexpr_fmt_atom,
    gshsexpr_applyvar, gshsexpr_var, gshsexpr_app, gshsexpr_lambda, gshsexpr_int, gshsexpr_string, gshsexpr_list, hsarg_var, hspos, hspos_import,
    gshsoutput_apply, gshsoutput_applyivar, gshsoutput_app, gshsoutput_lambda, gshsoutput_list, gshsoutput_ivar, gshsoutput_var, gshsoutput_int, gshsoutput_pos
  ) where

import GSI.Syn (gsvar)
import GSI.Value (gslambda_value, gsconstr, gsav)
import GSI.ByteCode (gsbcarg, gsbcconstr, gsbcconstr_view)
$gsimports

gssource_comp_char = $gslambda_value $ \ ch -> $gsbcconstr (gsvar "char") [ $gsav ch ]
gssource_comp_pos = $gslambda_value $ \ pos -> $gsbcconstr (gsvar "pos") [ $gsav pos ]
gssource_comp_imports = $gsconstr (gsvar "imports") []
gssource_comp_declare = $gslambda_value $ \ gsv -> $gsbcarg $ \ hsv -> $gsbcconstr (gsvar "declare") [ $gsav gsv, $gsav hsv ]
gssource_comp_value = $gslambda_value $ \ pos0 -> $gsbcarg $ \ ps -> $gsbcarg $ \ pos1 -> $gsbcarg $ \ e -> $gsbcconstr (gsvar "value") [ $gsav pos0, $gsav ps, $gsav pos1, $gsav e ]
gssource_comp_expr = $gslambda_value $ \ ps -> $gsbcarg $ \ pos -> $gsbcarg $ \ e -> $gsbcconstr (gsvar "expr") [ $gsav ps, $gsav pos, $gsav e ]

gssource_comp_char_view = $gsbcconstr_view "char"
gssource_comp_pos_view = $gsbcconstr_view "pos"
gssource_comp_imports_view = $gsbcconstr_view "imports"
gssource_comp_declare_view = $gsbcconstr_view "declare"
gssource_comp_value_view = $gsbcconstr_view "value"
gssource_comp_expr_view = $gsbcconstr_view "expr"

gsquote_param_hsvs = $gslambda_value $ \ vs -> $gsbcconstr (gsvar "hsvs") [ $gsav vs ]

gsquote_param_hsvs_view = $gsbcconstr_view "hsvs"

gsdest_comp_char = $gslambda_value $ \ ch -> $gsbcconstr (gsvar "char") [ $gsav ch ]
gsdest_comp_pos = $gslambda_value $ \ pos -> $gsbcconstr (gsvar "pos") [ $gsav pos ]
gsdest_comp_imports = $gsconstr (gsvar "imports") []
gsdest_comp_expr = $gslambda_value $ \ is -> $gsbcarg $ \ e -> $gsbcconstr (gsvar "expr") [ $gsav is, $gsav e ]

gsdest_comp_char_view = $gsbcconstr_view "char"
gsdest_comp_pos_view = $gsbcconstr_view "pos"
gsdest_comp_imports_view = $gsbcconstr_view "imports"
gsdest_comp_expr_view = $gsbcconstr_view "expr"

gshsimport_fmt = [gs:value| λ 'i. λ 's. analyze i.
    case hsimport.var 'm 'f. qq{import §(m) (§(f))\n§(s)}
    case hsimport.type 'm 'ty. qq{import §(m) (§(ty)(..))\n§(s)}
|]

gshsimport_cmp = [gs:value| λ 'i0. λ 'i1. analyze i0.
    case hsimport.var 'm0 'v0. (analyze i1.
        case hsimport.type 'm1 'ty1. gt
        case hsimport.var 'm1 'v1. ord.<|> (list.<=> rune.<=> m0 m1) (list.<=> rune.<=> v0 v1)
    )
    case hsimport.type 'm0 'ty0. (analyze i1.
        case hsimport.var 'm1 'v1. lt
        case hsimport.type 'm1 'ty1. ord.<|> (list.<=> rune.<=> m0 m1) (list.<=> rune.<=> ty0 ty1)
    )
|]

gshsimport_var = $gslambda_value $ \ m -> $gsbcarg $ \ f -> $gsbcconstr (gsvar "var") [ $gsav m, $gsav f ]
gshsimport_type = $gslambda_value $ \ m -> $gsbcarg $ \ ty -> $gsbcconstr (gsvar "type") [ $gsav m, $gsav ty ]

gshsimport_var_view = $gsbcconstr_view "var"
gshsimport_type_view = $gsbcconstr_view "type"

$gsdeclare fmt-list gsfmt_list

gshsexpr_fmt_atom = [gs:value| λ 'e. analyze e.
    case hsexpr.var 'v. (<>) v
    case hsexpr.string 's. (:) r{"} ∘ (<>) s ∘ (:) r{"}
    case hsexpr.list 'es. (:) r{\[} ∘ fmt-list es ∘ (:) r{\]}
    case hsexpr.int 'n. (<>) (fmt-decimal n)
    case hsexpr.app _ _. (:) r{\(} ∘ hsexpr.fmt e ∘ (:) r{\)}
    case hsexpr.lambda _ _. (:) r{\(} ∘ hsexpr.fmt e ∘ (:) r{\)}
|]

$gsdeclare fmt-list-w gsfmt_list_w

gsfmt_list = [gs:value| λ 'es. analyze es.
    case nil. λ 's. s
    case _. (:) r{ } ∘ fmt-list-w es
|]

gsfmt_list_w = [gs:value| λ 'es. analyze es.
    case 'e:nil. hsexpr.fmt e ∘ (:) r{ }
    case 'e:'es. hsexpr.fmt e ∘ (<>) qq{, } ∘ fmt-list-w es
|]

gshsexpr_fmt = [gs:value| λ 'e. analyze e.
    case hsexpr.var _. hsexpr.fmt-atom e
    case hsexpr.app 'f 'x. hsexpr.fmt f ∘ (:) r{ } ∘ hsexpr.fmt-atom x
    case hsexpr.lambda 'x 'e. (<>) qq{\\ } ∘ (<>) x ∘ (<>) qq{ -> } ∘ hsexpr.fmt e
    case hsexpr.list _. hsexpr.fmt-atom e
|]

gshsexpr_applyvar = [gs:value| λ 'f. λ 'as. foldl hsexpr.app (hsexpr.var f) as |]

gshsexpr_var = $gslambda_value $ \ v -> $gsbcconstr (gsvar "var") [ $gsav v ]
gshsexpr_app = $gslambda_value $ \ f -> $gsbcarg $ \ x -> $gsbcconstr (gsvar "app") [ $gsav f, $gsav x ]
gshsexpr_lambda = $gslambda_value $ \ x -> $gsbcarg $ \ e -> $gsbcconstr (gsvar "lambda") [ $gsav x, $gsav e ]
gshsexpr_int = $gslambda_value $ \ n -> $gsbcconstr (gsvar "int") [ $gsav n ]
gshsexpr_string = $gslambda_value $ \ s -> $gsbcconstr (gsvar "string") [ $gsav s ]
gshsexpr_list = $gslambda_value $ \ es -> $gsbcconstr (gsvar "list") [ $gsav es ]

gshsexpr_var_view = $gsbcconstr_view "var"
gshsexpr_string_view = $gsbcconstr_view "string"
gshsexpr_list_view = $gsbcconstr_view "list"
gshsexpr_int_view = $gsbcconstr_view "int"
gshsexpr_app_view = $gsbcconstr_view "app"
gshsexpr_lambda_view = $gsbcconstr_view "lambda"

hsarg_var = [gs:value| hsexpr.app (hsexpr.var qq{GSArgVar}) |]

hspos = [gs:value| λ 'pos. hsexpr.applyvar qq{Pos} (hsexpr.string (pos #filename) : hsexpr.int (pos #line) : hsexpr.int (pos #col) : nil) |]

hspos_import = [gs:value| hsimport.type qq{GSI.Util} qq{Pos} |]

gshsoutput_apply = [gs:value| λ 'pf. λ 'pas. foldl hsoutput.app pf pas |]
gshsoutput_applyivar = [gs:value| λ 'm. λ 'f. λ 'pas. hsoutput.apply (hsoutput.ivar m f) pas |]

gshsoutput_app = [gs:value| λ 'pf. λ 'pa. 〈 '0 ∝ ordered-set.∪ hsimport.<=> (pf #0) (pa #0); '1 ∝ hsexpr.app (pf #1) (pa #1); 〉 |]

gshsoutput_lambda = [gs:value| λ 'x. λ 'b. 〈 '0 ∝ b #0; '1 ∝ hsexpr.lambda x (b #1); 〉 |]
gshsoutput_list = [gs:value| λ 'ps. 〈 '0 ∝ ordered-set.unions hsimport.<=> (map (λ 'p. p #0) ps); '1 ∝ hsexpr.list (map (λ 'p. p #1) ps); 〉 |]

gshsoutput_ivar = [gs:value| λ 'm. λ 'hsv. 〈 '0 ∝ ordered-set.singleton (hsimport.var m hsv); '1 ∝ hsexpr.var hsv; 〉 |]
gshsoutput_var = [gs:value| λ 'hsv. 〈 '0 ∝ ordered-set.empty; '1 ∝ hsexpr.var hsv; 〉 |]
gshsoutput_int = [gs:value| λ 'n. 〈 '0 ∝ ordered-set.empty; '1 ∝ hsexpr.int n; 〉 |]

gshsoutput_pos = [gs:value| λ 'pos. 〈 '0 ∝ ordered-set.singleton hspos-import; '1 ∝ hspos pos; 〉 |]
