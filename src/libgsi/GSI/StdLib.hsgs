{-# LANGUAGE TemplateHaskell, ScopedTypeVariables #-}
module GSI.StdLib (gsvalue, gslambda, gscompose, gsapply_fn, gsanalyze, gsanalyzeM, gsimpanalyzeM, gscase, gserror, gsundefined, gsrecord_and, gsfor, gsimpfor, gsimpunit, gsinfalliblepattern) where

import GSI.Util (StackTrace(..), gshere)
import GSI.Syn (gsvar, fmtVarAtom)
import GSI.Value (GSValue(..), gslambda_value, gsvenvUnion, gsav, gsae, gsvCode)
import GSI.ByteCode (gsbcat_w, gsbcarg, gsbcapply, gsbcforce, gsbcenter, gsbcconstr, gsbcerror, gsbcundefined, gsbcimpfor, gsbcimpbind, gsbcimpbody, gsbcimpunit, gsbcfmterrormsg, gsbcimplementationfailure)
import GSI.BCFunctions (gsbcevalstacktrace)
$gsimports

gsvalue = $gslambda_value $ \ v -> $gsbcenter v

gslambda = $gslambda_value $ \ stv -> $gsbcevalstacktrace ($gsav stv) $ \ (StackTrace pos cs) ->
    $gsbcarg $ \ p -> $gsbcarg $ \ b -> gsbcat_w pos cs $ gsbcarg_w pos $ \ x ->
        $gsbcforce ($gsae $ $gsbcapply p [$gsav x]) $ \ r -> $gsbcapply b [$gsav r]

gscompose :: GSValue
gscompose = [gs:value| λ 'f. λ 'g. λ 'x. f (g x) |]

gsapply_fn = [gs:value| λ 'f. λ 'x. f x |]

gsanalyze = [gs:value| λ 'e. λ 'cs. cs e |]

gsanalyzeM = [gs:value| λ 'm. λ 'e. λ 'cs. m #(>>=) e cs |]

gsimpanalyzeM = $gslambda_value $ \ a -> $gsbcarg $ \cs -> $gsbcimpfor $ do
    x <- $gsbcimpbind $ $gsav a
    $gsbcimpbody $ $gsae $ $gsbcapply cs [ $gsav x ]

gscase = $gslambda_value $ \ p -> $gsbcarg $ \ b -> $gsbcarg $ \ e -> $gsbcarg $ \ x ->
    $gsbcforce ($gsae $ $gsbcapply p [$gsav x]) $ \ c -> case c of
        GSConstr pos cv [r] | cv == gsvar "1" -> $gsbcapply b [$gsav r]
        GSConstr pos cv [] | cv == gsvar "0" -> $gsbcapply e [$gsav x]
        GSConstr pos cc args -> $gsbcimplementationfailure $ "gscase (pattern returns " ++ fmtVarAtom cc ") next" -- Probably §hs{$gsbcbranch ($gsav e) ($gsav b) c}
        _ -> $gsbcimplementationfailure $ "gscase (pattern returns " ++ gsvCode c ++ ") next" -- Probably §hs{$gsbcbranch ($gsav e) ($gsav b) c}

gsrecord_and = $gslambda_value $ \ r0 -> $gsbcarg $ \ r1 -> $gsbcforce ($gsav r0) $ \ r0v -> $gsbcforce ($gsav r1) $ \ r1v -> case (r0v, r1v) of
    (GSRecord pos0 env0, GSRecord pos1 env1) -> $gsbcenter (GSRecord $gshere (gsvenvUnion env0 env1))
    _ -> $gsbcimplementationfailure $ "gsrecord_and " ++ gsvCode r0v ++ ' ' : gsvCode r1v ++ " next"

gsfor :: GSValue
gsfor = $gslambda_value $ \ g -> $gsbcarg $ \ e -> $gsbcforce ($gsav g) $ \ env -> $gsbcapply e [ $gsav env ]

gsimpfor :: GSValue
gsimpfor = $gslambda_value $ \ g -> $gsbcarg $ \ e -> $gsbcimpfor $ do
    env <- $gsbcimpbind $ $gsav g
    $gsbcimpbody $ $gsae $ $gsbcapply e [ $gsav env ]

gsimpunit = $gslambda_value $ \ x -> $gsbcimpfor $ do $gsbcimpunit $ $gsav x

gserror = $gslambda_value $ \ stv -> $gsbcarg $ \ msgv ->
    $gsbcevalstacktrace ($gsav stv) $ \ st_hs ->
    $gsbcfmterrormsg ($gsav msgv) $ \ msg_s ->
    gsbcerror st_hs msg_s

gsundefined = $gslambda_value $ \ stv -> $gsbcevalstacktrace ($gsav stv) $ \ st_hs ->
    gsbcundefined st_hs

gsinfalliblepattern = $gslambda_value $ \ p -> $gsbcarg $ \ x ->
    $gsbcforce ($gsae ($gsbcapply p [ $gsav x ])) $ \ r -> $gsbcconstr (gsvar "1") [$gsav r]
