{-# LANGUAGE TemplateHaskell, ScopedTypeVariables #-}
module GSI.List (gsappend, gsfoldl, gsfoldr, gsmap, gsrepeat, gszip, gsmap2, gsmap3, gsdrop, gscons, gsnil, gscons_view, gsnil_view) where

import GSI.Util (gshere)
import GSI.Syn (gsvar)
import GSI.Value (GSValue(..), gslambda_value, gsav)
import GSI.ByteCode (gsbcarg, gsbcconstr, gsbcconstr_view)
$gsimports

gsappend :: GSValue
gsappend = [gs:value| λ 'xn. λ 'ys. analyze xn.
    case 'x:'xn1. x : (xn1 <> ys)
    case nil. ys
|]

gsfoldl = [gs:value| λ 'f. λ 'z. λ 'xn. analyze xn.
    case nil. z
    case 'x:'xn1. foldl f (f z x) xn1
|]

gsfoldr = [gs:value| λ 'f. λ 'z. λ 'xn. analyze xn.
    case nil. z
    case 'x:'xn1. f x (foldr f z xn1)
|]

gsmap = [gs:value| λ 'f. λ 'xn. analyze xn.
    case 'x:'xn1. f x : map f xn1
    case nil. nil
|]

gsrepeat = [gs:value| λ 'x. x : repeat x |]

gszip = [gs:value| λ 'xn. λ 'ys. analyze xn.
    case 'x:'xn1. (analyze ys.
        case 'y:'ys1. 〈 '0 ∝ x; '1 ∝ y; 〉 : zip xn1 ys1
    )
    case _. nil
|]

gsmap2 = [gs:value| λ 'f. λ 'xn. λ 'ys. analyze xn.
    case 'x:'xn1. (analyze ys.
        case 'y:'ys1. f x y : map2 f xn1 ys1
    )
    case _. nil
|]

gsmap3 = [gs:value| λ 'f. λ 'xn. λ 'ys. λ 'zs. analyze xn.
|]

gsdrop = [gs:value| λ 'n. λ 'xn. analyze n -? 1.
    case nothing. xn
    case just 'n1. (analyze xn.
        case nil. nil
        case _ : 'xn1. drop n1 xn1
    )
|]

gscons :: GSValue
gscons = $gslambda_value $ \ x -> $gsbcarg $ \ xn -> $gsbcconstr (gsvar ":") [ $gsav x, $gsav xn ]

gsnil :: GSValue
gsnil = GSConstr $gshere (gsvar "nil") []

gscons_view :: GSValue
gscons_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ xn -> $gsbcconstr_view ":" ek sk xn

gsnil_view :: GSValue
gsnil_view = $gslambda_value $ \ ek -> $gsbcarg $ \ sk -> $gsbcarg $ \ xn -> $gsbcconstr_view "nil" ek sk xn
